<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>demo - 设计模式</title>

  <!-- styles -->
  <link rel="stylesheet" href="/doc-builder/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/doc-builder/resource/style.css" />
  <link rel="stylesheet" href="/doc-builder/resource/lib/highlight.default.min.css" />
  <link rel="stylesheet" href="/doc-builder/resource/lib/viewerjs-1.10.5/viewer.min.css" />

  <!-- scripts -->
  <script src="/doc-builder/resource/lib/jquery.min.js"></script>

  <link rel="manifest" href="/doc-builder/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/doc-builder/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/doc-builder/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/doc-builder/resource/favicon.ico" />

  <!-- 编译时间：2022/8/14 13:18:31 -->

  <script>
    window.root = '/doc-builder';

    // 提前把搜索数据库载入内存
    fetch(`${window.root}/dir_tree.json`)
      .then(function (res) {
        return res.json();
      })
      .then(function (res) {
        window.__doc_builder_dirTree__ = res;
      });
  </script>
</head>

  <body>
    <ul class="menu expand" id="menu">
      <div class="loading">
        <span>加载中...</span>
      </div>
      <div class="search_bar" id="search_bar">
        <input type="text" placeholder="search..." />
        <img
          class="clear"
          id="clear"
          src="/doc-builder/resource/icons/circle-xmark.svg"
          alt=""
        />
        <div class="search_result" id="search_result"></div>
      </div>
      
            <ul class="parent expand">
              <li id="前端技术" class="dir" title="前端技术">
                <span>前端技术</span>
                <div class="triangle"></div>
              </li>
              
            <ul class="parent expand">
              <li id="前端技术\浏览器" class="dir" title="浏览器">
                <span>浏览器</span>
                <div class="triangle"></div>
              </li>
              
          <li id="前端技术\浏览器\事件循环.md" class="children" title="事件循环">
            <a href="/doc-builder/前端技术\浏览器/事件循环.html">事件循环</a>
          </li>
        
          <li id="前端技术\浏览器\浏览器.md" class="children" title="浏览器">
            <a href="/doc-builder/前端技术\浏览器/浏览器.html">浏览器</a>
          </li>
        
          <li id="前端技术\浏览器\浏览器架构.md" class="children" title="浏览器架构">
            <a href="/doc-builder/前端技术\浏览器/浏览器架构.html">浏览器架构</a>
          </li>
        
          <li id="前端技术\浏览器\浏览器缓存.md" class="children" title="浏览器缓存">
            <a href="/doc-builder/前端技术\浏览器/浏览器缓存.html">浏览器缓存</a>
          </li>
        
            </ul>
          
            <ul class="parent expand">
              <li id="前端技术\React" class="dir" title="React">
                <span>React</span>
                <div class="triangle"></div>
              </li>
              
          <li id="前端技术\React\Fiber.md" class="children" title="Fiber">
            <a href="/doc-builder/前端技术\React/Fiber.html">Fiber</a>
          </li>
        
          <li id="前端技术\React\Hooks.md" class="children" title="Hooks">
            <a href="/doc-builder/前端技术\React/Hooks.html">Hooks</a>
          </li>
        
          <li id="前端技术\React\React.md" class="children" title="React">
            <a href="/doc-builder/前端技术\React/React.html">React</a>
          </li>
        
            </ul>
          
            <ul class="parent expand">
              <li id="前端技术\Javascript" class="dir" title="Javascript">
                <span>Javascript</span>
                <div class="triangle"></div>
              </li>
              
          <li id="前端技术\Javascript\Promise.md" class="children" title="Promise">
            <a href="/doc-builder/前端技术\Javascript/Promise.html">Promise</a>
          </li>
        
          <li id="前端技术\Javascript\代理对.md" class="children" title="代理对">
            <a href="/doc-builder/前端技术\Javascript/代理对.html">代理对</a>
          </li>
        
          <li id="前端技术\Javascript\其他.md" class="children" title="其他">
            <a href="/doc-builder/前端技术\Javascript/其他.html">其他</a>
          </li>
        
          <li id="前端技术\Javascript\原型链和继承.md" class="children" title="原型链和继承">
            <a href="/doc-builder/前端技术\Javascript/原型链和继承.html">原型链和继承</a>
          </li>
        
          <li id="前端技术\Javascript\数据类型.md" class="children" title="数据类型">
            <a href="/doc-builder/前端技术\Javascript/数据类型.html">数据类型</a>
          </li>
        
          <li id="前端技术\Javascript\模块.md" class="children" title="模块">
            <a href="/doc-builder/前端技术\Javascript/模块.html">模块</a>
          </li>
        
          <li id="前端技术\Javascript\正则表达式.md" class="children" title="正则表达式">
            <a href="/doc-builder/前端技术\Javascript/正则表达式.html">正则表达式</a>
          </li>
        
          <li id="前端技术\Javascript\闭包.md" class="children" title="闭包">
            <a href="/doc-builder/前端技术\Javascript/闭包.html">闭包</a>
          </li>
        
            </ul>
          
          <li id="前端技术\Babel.md" class="children" title="Babel">
            <a href="/doc-builder/前端技术/Babel.html">Babel</a>
          </li>
        
          <li id="前端技术\CSS.md" class="children" title="CSS">
            <a href="/doc-builder/前端技术/CSS.html">CSS</a>
          </li>
        
          <li id="前端技术\Flex布局.md" class="children" title="Flex布局">
            <a href="/doc-builder/前端技术/Flex布局.html">Flex布局</a>
          </li>
        
          <li id="前端技术\NodeJS.md" class="children" title="NodeJS">
            <a href="/doc-builder/前端技术/NodeJS.html">NodeJS</a>
          </li>
        
          <li id="前端技术\npm.md" class="children" title="npm">
            <a href="/doc-builder/前端技术/npm.html">npm</a>
          </li>
        
          <li id="前端技术\Typescript.md" class="children" title="Typescript">
            <a href="/doc-builder/前端技术/Typescript.html">Typescript</a>
          </li>
        
          <li id="前端技术\Webpack.md" class="children" title="Webpack">
            <a href="/doc-builder/前端技术/Webpack.html">Webpack</a>
          </li>
        
          <li id="前端技术\函数式编程.md" class="children" title="函数式编程">
            <a href="/doc-builder/前端技术/函数式编程.html">函数式编程</a>
          </li>
        
          <li id="前端技术\微前端.md" class="children" title="微前端">
            <a href="/doc-builder/前端技术/微前端.html">微前端</a>
          </li>
        
          <li id="前端技术\性能优化.md" class="children" title="性能优化">
            <a href="/doc-builder/前端技术/性能优化.html">性能优化</a>
          </li>
        
          <li id="前端技术\柯里化.md" class="children" title="柯里化">
            <a href="/doc-builder/前端技术/柯里化.html">柯里化</a>
          </li>
        
          <li id="前端技术\设计模式.md" class="children" title="设计模式">
            <a href="/doc-builder/前端技术/设计模式.html">设计模式</a>
          </li>
        
            </ul>
          
          <li id="单元测试.md" class="children" title="单元测试">
            <a href="/doc-builder/单元测试.html">单元测试</a>
          </li>
        
          <li id="网络.md" class="children" title="网络">
            <a href="/doc-builder/网络.html">网络</a>
          </li>
        
      <li id="index.md" class="children about">
        <a href="/doc-builder/">关于</a>
      </li>
    </ul>
    <div class="drager" id="drager">
      <div class="switcher btn" id="switcher" title="展开或收起"></div>
      <div class="expand-all btn" id="expand-all" title="展开所有"></div>
      <div class="collapse-all btn" id="collapse-all" title="收起所有"></div>
    </div>
    <div class="mobile_menu" id="mobile_menu">
      <img src="/doc-builder/resource/icons/bars.svg" alt="" />
    </div>
    <div class="content markdown-body">
      <h1 id="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></h1>
<h1 id="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99" tabindex="-1"><a class="header-anchor" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99">设计模式原则</a></h1>
<ul>
<li>
<p>单一职责原则</p>
<ul>
<li>一个程序只做好一件事</li>
<li>如果功能过于复杂就拆分开，每个部分保持独立</li>
<li>比如 Promise，每个 then 只做一件事</li>
</ul>
</li>
<li>
<p>开放/封闭原则</p>
<ul>
<li>对扩展开放，对修改封闭</li>
<li>增加需求时，扩展新代码，而非修改已有代码</li>
<li>比如 Promise，如果新增需求，扩展 then</li>
<li>比如为表单校验类增加拓展接口而不是修改内部代码</li>
</ul>
<pre><code class="language-jsx"><span class="hljs-comment">// 优化前</span>
<span class="hljs-keyword">let</span> checkType = <span class="hljs-keyword">function</span> (<span class="hljs-params">str, type</span>) {
  <span class="hljs-keyword">switch</span> (type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;email&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.<span class="hljs-title function_">test</span>(str);
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mobile&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^1[3|4|5|7|8][0-9]{9}$/</span>.<span class="hljs-title function_">test</span>(str);
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tel&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/</span>.<span class="hljs-title function_">test</span>(str);
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
};
<span class="hljs-comment">// const result = checkType(&#x27;165226226326&#x27;,&#x27;mobile&#x27;)</span>
<span class="hljs-comment">// 优化后</span>
<span class="hljs-keyword">let</span> checkType = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> rules = {
    <span class="hljs-title function_">email</span>(<span class="hljs-params">str</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.<span class="hljs-title function_">test</span>(str);
    },
    <span class="hljs-title function_">mobile</span>(<span class="hljs-params">str</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^1[3|4|5|7|8][0-9]{9}$/</span>.<span class="hljs-title function_">test</span>(str);
    },
  };
  <span class="hljs-comment">//暴露接口</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">//校验</span>
    <span class="hljs-title function_">check</span>(<span class="hljs-params">str, type</span>) {
      <span class="hljs-keyword">return</span> rules[type] ? rules[type](str) : <span class="hljs-literal">false</span>;
    },
    <span class="hljs-comment">//添加规则</span>
    <span class="hljs-title function_">addRule</span>(<span class="hljs-params">type, fn</span>) {
      rules[type] = fn;
    },
  };
})();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(checkType.<span class="hljs-title function_">check</span>(<span class="hljs-string">&#x27;188170239&#x27;</span>, <span class="hljs-string">&#x27;mobile&#x27;</span>));
checkType.<span class="hljs-title function_">addRule</span>(<span class="hljs-string">&#x27;money&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^[0-9]+(.[0-9]{2})?$/</span>.<span class="hljs-title function_">test</span>(str);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(checkType.<span class="hljs-title function_">check</span>(<span class="hljs-string">&#x27;18.36&#x27;</span>, <span class="hljs-string">&#x27;money&#x27;</span>));
</code></pre>
</li>
<li>
<p>里氏替换原则</p>
<ul>
<li>子类能覆盖父类</li>
<li>父类能出现的地方子类就能出现</li>
</ul>
</li>
<li>
<p>接口隔离原则</p>
<ul>
<li>保持接口的单一独立</li>
</ul>
</li>
<li>
<p>依赖倒转原则</p>
<ul>
<li>面向接口编程，依赖于抽象而不依赖于具体</li>
<li>使用方只关注接口而不关注具体类的实现</li>
</ul>
</li>
</ul>
<h1 id="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB" tabindex="-1"><a class="header-anchor" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB">设计模式分类</a></h1>
<h2 id="%E5%88%9B%E5%BB%BA%E5%9E%8B" tabindex="-1"><a class="header-anchor" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B">创建型</a></h2>
<ul>
<li>单例模式</li>
<li>原型模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
</ul>
<h2 id="%E7%BB%84%E5%90%88%E5%9E%8B%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E7%BB%84%E5%90%88%E5%9E%8B%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%89">组合型（结构型）</a></h2>
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h2 id="%E8%A1%8C%E4%B8%BA%E5%9E%8B" tabindex="-1"><a class="header-anchor" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B">行为型</a></h2>
<ul>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>职责链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
<h1 id="%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a></h1>
<h2 id="%E5%9C%BA%E6%99%AF" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF">场景</a></h2>
<ul>
<li>需要依赖具体环境创建不同实例，实例都有相同的行为</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;init&#x27;</span>);
  }
  <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun&#x27;</span>);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> {
  <span class="hljs-title function_">create</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name);
  }
}
<span class="hljs-keyword">let</span> factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>();
<span class="hljs-keyword">let</span> p = factory.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;p1&#x27;</span>);
p.<span class="hljs-title function_">init</span>();
p.<span class="hljs-title function_">fun</span>();
</code></pre>
<h1 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></h1>
<ul>
<li>场景：登录框、vuex 和 redux 中的 store</li>
<li>一个类只有一个实例，并提供一个访问它的全局访问点</li>
<li>划分命名空间，减少全局变量</li>
<li>只会实例化一次。简化了代码的调试和维护，节约内存</li>
<li>有可能导致模块间的强耦合，从而不利于单元测试</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-1" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-1">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginForm</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;hide&#x27;</span>;
  }
  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;show&#x27;</span>) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;show&#x27;</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;显示&#x27;</span>);
  }
  <span class="hljs-title function_">hide</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;hide&#x27;</span>) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&#x27;hide&#x27;</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;隐藏&#x27;</span>);
  }
}
<span class="hljs-title class_">LoginForm</span>.<span class="hljs-property">getInstance</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> instance;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!instance) {
      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginForm</span>();
    }
    <span class="hljs-keyword">return</span> instance;
  };
})();
<span class="hljs-keyword">let</span> obj1 = <span class="hljs-title class_">LoginForm</span>.<span class="hljs-title function_">getInstance</span>();
obj1.<span class="hljs-title function_">show</span>();
<span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">LoginForm</span>.<span class="hljs-title function_">getInstance</span>();
obj2.<span class="hljs-title function_">hide</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1 === obj2); <span class="hljs-comment">// true</span>
</code></pre>
<h1 id="%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></h1>
<ul>
<li>将一个类的接口转化为另外一个接口，以满足需求，使类之间接口不兼容问题通过适配器得以解决</li>
<li>可以让任何两个没有关联的类一起运行，提高了类的复用</li>
<li>额外对象的创建，非直接调用，存在一定的开销</li>
<li>场景：整合第三方 SDK、封装旧接口</li>
<li>适配器与代理模式相似，适配器模式提供一个不同的接口，代理模式提供一模一样的接口</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-2" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-2">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plug</span> {
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;iphone充电头&#x27;</span>;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">plug</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plug</span>();
  }
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">plug</span>.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&#x27; 适配器Type-c充电头&#x27;</span>;
  }
}
<span class="hljs-keyword">let</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();
target.<span class="hljs-title function_">getName</span>();
</code></pre>
<pre><code class="language-jsx"><span class="hljs-comment">// 自己封装的ajax， 使用方式如下</span>
<span class="hljs-title function_">ajax</span>({ <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Post&#x27;</span>, <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-attr">data</span>: { <span class="hljs-attr">test</span>: <span class="hljs-number">111</span> } }).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {});
<span class="hljs-comment">// 因为历史原因，代码中全都是：</span>
<span class="hljs-comment">// $.ajax({....})</span>
<span class="hljs-comment">// 做一层适配器</span>
<span class="hljs-keyword">var</span> $ = {
  <span class="hljs-attr">ajax</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">ajax</span>(options);
  },
};
</code></pre>
<h1 id="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a></h1>
<ul>
<li>在不改变原对象的基础上，动态的给对象添加额外职责，对其进行包装扩展，是实现继承的一种替代方案</li>
<li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦</li>
<li>方便动态的扩展功能，且提供了比继承更多的灵活性</li>
</ul>
<h2 id="%E7%BC%BA%E7%82%B9" tabindex="-1"><a class="header-anchor" href="#%E7%BC%BA%E7%82%B9">缺点</a></h2>
<ul>
<li>多层装饰比较复杂</li>
<li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭</li>
</ul>
<h1 id="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a></h1>
<ul>
<li>为一个对象提供一个代用品或占位符，以便控制对它的访问</li>
<li>能将代理对象与被调用对象分离，降低耦合度，可以起到保护目标对象的作用</li>
<li>代理对象可以扩展目标对象的功能，通过修改代理对象就可以了，符合开闭原则</li>
</ul>
<h2 id="%E5%9C%BA%E6%99%AF-1" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF-1">场景</a></h2>
<ul>
<li>做授权控制</li>
<li>HTML 元素事件代理</li>
<li>ES6 的 proxy</li>
</ul>
<h2 id="%E7%BC%BA%E7%82%B9-1" tabindex="-1"><a class="header-anchor" href="#%E7%BC%BA%E7%82%B9-1">缺点</a></h2>
<ul>
<li>处理请求速度可能有差别，非直接访问存在开销</li>
</ul>
<h1 id="%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">外观模式</a></h1>
<ul>
<li>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用</li>
<li>减少系统相互依赖，提高灵活性、安全性</li>
<li>缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适</li>
</ul>
<h2 id="%E5%9C%BA%E6%99%AF-2" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF-2">场景</a></h2>
<ul>
<li>兼容浏览器事件绑定</li>
<li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade</li>
<li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖</li>
<li>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作</li>
</ul>
<h1 id="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89">观察者模式（发布订阅模式）</a></h1>
<ul>
<li>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式</li>
<li>缺点：过度使用会导致对象与对象之间的联系弱化，会导致难以跟踪维护和理解</li>
</ul>
<h2 id="%E5%9C%BA%E6%99%AF-3" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF-3">场景</a></h2>
<ul>
<li>DOM 事件</li>
<li>vue 事件总线</li>
</ul>
<h1 id="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">状态模式</a></h1>
<ul>
<li>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</li>
</ul>
<h1 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></h1>
<ul>
<li>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示</li>
<li>访问一个聚合对象的内容而无需暴露它的内部表示</li>
<li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li>
<li>对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式</li>
</ul>
<h2 id="%E5%9C%BA%E6%99%AF-4" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF-4">场景</a></h2>
<ul>
<li>Array.prototype.forEach</li>
<li>ES6 Iterator</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-3" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-3">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">conatiner</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = conatiner.<span class="hljs-property">list</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;
  }
  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasNext</span>()) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>++];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-title function_">hasNext</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">list</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = list;
  }
  <span class="hljs-title function_">getIterator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>(<span class="hljs-variable language_">this</span>);
  }
}
<span class="hljs-keyword">let</span> container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-keyword">let</span> iterator = container.<span class="hljs-title function_">getIterator</span>();
<span class="hljs-keyword">while</span> (iterator.<span class="hljs-title function_">hasNext</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());
}
</code></pre>
<h1 id="%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a></h1>
<ul>
<li>将抽象部分与它的实现部分分离，使它们都可以独立地变化</li>
<li>有助于独立地管理各组成部分， 把抽象化与实现化解耦</li>
<li>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-4" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-4">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, color</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;
  }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.color.name}</span> <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
}
<span class="hljs-keyword">let</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">&#x27;red&#x27;</span>);
<span class="hljs-keyword">let</span> yellow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);
<span class="hljs-keyword">let</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shape</span>(<span class="hljs-string">&#x27;circle&#x27;</span>, red);
circle.<span class="hljs-title function_">draw</span>();
<span class="hljs-keyword">let</span> triangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shape</span>(<span class="hljs-string">&#x27;triangle&#x27;</span>, yellow);
triangle.<span class="hljs-title function_">draw</span>();
</code></pre>
<h1 id="%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">组合模式</a></h1>
<ul>
<li>通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性</li>
<li>希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-5" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-5">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainOrder</span> {
  <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建火车票订单&#x27;</span>);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelOrder</span> {
  <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建酒店订单&#x27;</span>);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TotalOrder</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orderList</span> = [];
  }
  <span class="hljs-title function_">addOrder</span>(<span class="hljs-params">order</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orderList</span>.<span class="hljs-title function_">push</span>(order);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
  <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orderList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      item.<span class="hljs-title function_">create</span>();
    });
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
}
<span class="hljs-comment">// 可以在购票网站买车票同时也订房间</span>
<span class="hljs-keyword">let</span> train = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainOrder</span>();
<span class="hljs-keyword">let</span> hotel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelOrder</span>();
<span class="hljs-keyword">let</span> total = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TotalOrder</span>();
total.<span class="hljs-title function_">addOrder</span>(train).<span class="hljs-title function_">addOrder</span>(hotel).<span class="hljs-title function_">create</span>();
</code></pre>
<h1 id="%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a></h1>
<ul>
<li>用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-6" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-6">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">super</span>(name);
  }
  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello， My name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
}
<span class="hljs-keyword">let</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;xiaoming&#x27;</span>);
student.<span class="hljs-title function_">sayHello</span>();
</code></pre>
<h1 id="%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a></h1>
<ul>
<li>组成：一组策略类，封装了具体的算法，并负责具体的计算过程；环境类，接受客户的请求，将请求委托给某一个策略</li>
<li>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换</li>
<li>可以有效的避免多重条件选择语句</li>
<li>提供了对开放-封闭原则的支持，将算法封装在独立的策略中，使得它们易于切换，理解，易于扩展</li>
</ul>
<h2 id="%E5%9C%BA%E6%99%AF-5" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF-5">场景</a></h2>
<ul>
<li>一个系统需要动态地在几种算法中选择一种</li>
<li>表单验证</li>
</ul>
<h1 id="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">模板方法模式</a></h1>
<ul>
<li>模板方法模式由抽象父类、具体的实现子类组成。在抽象父类中封装了子类的算法框架，实现一些公共方法和封装子类中所有方法的执行顺序</li>
<li>子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法</li>
</ul>
<h2 id="%E5%9C%BA%E6%99%AF-6" tabindex="-1"><a class="header-anchor" href="#%E5%9C%BA%E6%99%AF-6">场景</a></h2>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li>
<li>子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-7" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-7">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Beverage</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">{ brewDrink, addCondiment }</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">brewDrink</span> = brewDrink;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">addCondiment</span> = addCondiment;
  }
  <span class="hljs-comment">/* 烧开水，共用方法 */</span>
  <span class="hljs-title function_">boilWater</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;水已经煮沸=== 共用&#x27;</span>);
  }
  <span class="hljs-comment">/* 倒杯子里，共用方法 */</span>
  <span class="hljs-title function_">pourCup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;倒进杯子里===共用&#x27;</span>);
  }
  <span class="hljs-comment">/* 模板方法 */</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">boilWater</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">brewDrink</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">pourCup</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addCondiment</span>();
  }
}
<span class="hljs-comment">/* 咖啡 */</span> <span class="hljs-keyword">const</span> coffee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Beverage</span>({
  <span class="hljs-comment">/* 冲泡咖啡，覆盖抽象方法 */</span>
  <span class="hljs-attr">brewDrink</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;冲泡咖啡&#x27;</span>);
  },
  <span class="hljs-comment">/* 加调味品，覆盖抽象方法 */</span>
  <span class="hljs-attr">addCondiment</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;加点奶和糖&#x27;</span>);
  },
});
coffee.<span class="hljs-title function_">init</span>();
</code></pre>
<h1 id="%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令模式</a></h1>
<ul>
<li>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能</li>
<li>命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行</li>
</ul>
<h2 id="%E7%A4%BA%E4%BE%8B-8" tabindex="-1"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B-8">示例</a></h2>
<pre><code class="language-jsx"><span class="hljs-comment">// 接收者类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> {
  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接收者执行请求&#x27;</span>);
  }
}
<span class="hljs-comment">// 命令者</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">receiver</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span> = receiver;
  }
  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;命令&#x27;</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span>.<span class="hljs-title function_">execute</span>();
  }
}
<span class="hljs-comment">// 触发者</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">command</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">command</span> = command;
  }
  <span class="hljs-title function_">invoke</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">command</span>.<span class="hljs-title function_">execute</span>();
  }
}
<span class="hljs-comment">// 仓库</span>
<span class="hljs-keyword">const</span> warehouse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();
<span class="hljs-comment">// 订单</span>
<span class="hljs-keyword">const</span> order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(warehouse);
<span class="hljs-comment">// 客户</span>
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>(order);
client.<span class="hljs-title function_">invoke</span>();
</code></pre>
<h1 id="%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F" tabindex="-1"><a class="header-anchor" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</a></h1>
<ul>
<li>所有的相关对象都通过中介者对象来通信，而不是互相引用</li>
<li>使网状的多对多关系变成了相对简单的一对多关系</li>
<li>类似于观察者模式，但是单向的，由中介者统一管理</li>
<li>例如表单的 onchange 事件，无论是输入框还是单选按钮，都统一与 onchange 通信，由 onchange 统一处理事件类型的差异，实现各个事件间的解耦</li>
</ul>

      
        <div class="btt withToc" id="btt"></div>
      
    </div>
    
    <div class="table-of-contents"><ul><li title="设计模式"><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" data-anchor="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li title="设计模式原则"><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99" data-anchor="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99">设计模式原则</a></li><li title="设计模式分类"><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB" data-anchor="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB">设计模式分类</a><ul><li title="创建型"><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B" data-anchor="#%E5%88%9B%E5%BB%BA%E5%9E%8B">创建型</a></li><li title="组合型（结构型）"><a href="#%E7%BB%84%E5%90%88%E5%9E%8B%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%89" data-anchor="#%E7%BB%84%E5%90%88%E5%9E%8B%EF%BC%88%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%89">组合型（结构型）</a></li><li title="行为型"><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B" data-anchor="#%E8%A1%8C%E4%B8%BA%E5%9E%8B">行为型</a></li></ul></li><li title="工厂模式"><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" data-anchor="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF" data-anchor="#%E5%9C%BA%E6%99%AF">场景</a></li><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B" data-anchor="#%E7%A4%BA%E4%BE%8B">示例</a></li></ul></li><li title="单例模式"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" data-anchor="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a><ul><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-1" data-anchor="#%E7%A4%BA%E4%BE%8B-1">示例</a></li></ul></li><li title="适配器模式"><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" data-anchor="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a><ul><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-2" data-anchor="#%E7%A4%BA%E4%BE%8B-2">示例</a></li></ul></li><li title="装饰者模式"><a href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F" data-anchor="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a><ul><li title="缺点"><a href="#%E7%BC%BA%E7%82%B9" data-anchor="#%E7%BC%BA%E7%82%B9">缺点</a></li></ul></li><li title="代理模式"><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" data-anchor="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF-1" data-anchor="#%E5%9C%BA%E6%99%AF-1">场景</a></li><li title="缺点"><a href="#%E7%BC%BA%E7%82%B9-1" data-anchor="#%E7%BC%BA%E7%82%B9-1">缺点</a></li></ul></li><li title="外观模式"><a href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F" data-anchor="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">外观模式</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF-2" data-anchor="#%E5%9C%BA%E6%99%AF-2">场景</a></li></ul></li><li title="观察者模式（发布订阅模式）"><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89" data-anchor="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89">观察者模式（发布订阅模式）</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF-3" data-anchor="#%E5%9C%BA%E6%99%AF-3">场景</a></li></ul></li><li title="状态模式"><a href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F" data-anchor="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">状态模式</a></li><li title="迭代器模式"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" data-anchor="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF-4" data-anchor="#%E5%9C%BA%E6%99%AF-4">场景</a></li><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-3" data-anchor="#%E7%A4%BA%E4%BE%8B-3">示例</a></li></ul></li><li title="桥接模式"><a href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F" data-anchor="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a><ul><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-4" data-anchor="#%E7%A4%BA%E4%BE%8B-4">示例</a></li></ul></li><li title="组合模式"><a href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" data-anchor="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">组合模式</a><ul><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-5" data-anchor="#%E7%A4%BA%E4%BE%8B-5">示例</a></li></ul></li><li title="原型模式"><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" data-anchor="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a><ul><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-6" data-anchor="#%E7%A4%BA%E4%BE%8B-6">示例</a></li></ul></li><li title="策略模式"><a href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" data-anchor="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF-5" data-anchor="#%E5%9C%BA%E6%99%AF-5">场景</a></li></ul></li><li title="模板方法模式"><a href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" data-anchor="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">模板方法模式</a><ul><li title="场景"><a href="#%E5%9C%BA%E6%99%AF-6" data-anchor="#%E5%9C%BA%E6%99%AF-6">场景</a></li><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-7" data-anchor="#%E7%A4%BA%E4%BE%8B-7">示例</a></li></ul></li><li title="命令模式"><a href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" data-anchor="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令模式</a><ul><li title="示例"><a href="#%E7%A4%BA%E4%BE%8B-8" data-anchor="#%E7%A4%BA%E4%BE%8B-8">示例</a></li></ul></li><li title="中介者模式"><a href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F" data-anchor="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</a></li></ul></div>
    

    <!-- bottom scripts -->
    <script src="/doc-builder/resource/lib/mark.js-8.11.1/jquery.mark.min.js"></script>
    <script src="/doc-builder/resource/lib/viewerjs-1.10.5/viewer.min.js"></script>
    <script src="/doc-builder/resource/lib/jquery-viewer-1.0.1/jquery-viewer.min.js"></script>
    <script src="/doc-builder/resource/script.js"></script>
  </body>
</html>
