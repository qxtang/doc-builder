[{"id":"前端技术","dirname":"前端技术","filename":"","basename":"","path":"D:\\repos\\doc-builder\\markdown","relative_path":"","output_path":"D:\\repos\\doc-builder\\docs","children":[{"id":"前端技术\\浏览器","dirname":"浏览器","filename":"","basename":"","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","children":[{"id":"前端技术\\浏览器\\事件循环.md","filename":"事件循环.md","basename":"事件循环","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\浏览器","relative_path":"前端技术\\浏览器","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\浏览器","content":"参考https://juejin.cn/post/6844904165462769678https://juejin.cn/post/6844903919789801486js 为什么是单线程与 js 的用途有关如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，渲染器就不知道以哪个线程为准，DOM 渲染的结果不可预期多线程具有复杂性，编码的复杂性会增高为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。事件循环为什么：由于使用场景的原因，js 是设计成单线程的，为了更好的处理异步任务，所以设计了这个事件循环的机制同步任务和异步任务JavaScript 单线程任务分为同步任务和异步任务JavaScript 有一个主线程(js 引擎线程)和调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行在遇到异步任务时（setTimeout、DOM 事件、ajax 等），会转交给浏览器的其他工作线程（事件触发线程、定时器线程）执行，执行完之后将回调函数放入到任务队列事件触发线程管理一个任务队列，调用栈中的代码调用某些异步 API 时会在任务队列中添加事件，异步任务触发条件达成，将回调事件放到任务队列中当主线程的任务执行完了（执行栈空了），js 会去询问事件队列有没有回到函数需要执行（所以 setTimeout 0 会等到最后才执行）如此循环往复，形成事件循环机制事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行宏任务和微任务任务队列又分微任务队列和宏任务队列宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。宏任务（多为运行环境 api）：script 标签中的代码、UI 渲染、UI 交互、setTimeout/setInterval/setImmediate、DOM 事件、postMessage、ajax 请求、requestAnimationFrame宏任务代表一个个离散的、独立工作单元，运行完任务后，浏览器可以继续其他调度，如重新渲染页面的 UI 或执行垃圾回收微任务（多为语法）：Promise.then catch finally、MutationObserver、async/await、process.nextTick（NodeJS）微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的 UI。微任务的案例包括 promise 回调函数、DOM 发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染 UI 之前执行指定的行为，避免不必要的 UI 重绘，UI 重绘会使应用程序的状态不连续两者区别：宏任务：DOM 渲染后触发微任务：DOM 渲染前触发当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行事件循环流程从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；当微任务队列清空后，一个事件循环结束；接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止当微任务队列处理完成并清空时，事件循环会检查是否需要更新 UI 渲染，如果是，则会重新渲染 UI 视图单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理为什么微任务执行更早微任务是语法规定的宏任务是由浏览器规定的（web api）宏任务执行时间一般比较长每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的页面渲染每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。通常我们浏览器页面刷新频率是 60fps，也就是意味着 16.67ms 要刷新一次，因此我们也要尽量保证一次事件循环控制在 16.67ms 之内，这也是我们需要做代码性能优化的一个原因。requestAnimationFrame 在重新渲染屏幕之前执行，非常适合用来做动画resize 和 scroll 事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上执行 setTimeout/setInterval 时发生了什么JS 引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中执行 XHR/fetch 时发生了什么JS 引擎线程通知异步 http 请求线程，发送一个网络请求，并制定请求完成后的回调事件， 而异步 http 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中"},{"id":"前端技术\\浏览器\\浏览器.md","filename":"浏览器.md","basename":"浏览器","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\浏览器","relative_path":"前端技术\\浏览器","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\浏览器","content":"输入 URL 到网页渲染过程输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求查询资源缓存，强缓存、协商缓存DNS 解析为了让我们更快的拿到想要的 IP，DNS 广泛使用了缓存技术：浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会去操作系统中找路由缓存：路由器也有 DNS 缓存ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求根服务器：ISP 的 DNS 服务器找不到之后，就要向根服务器发出请求，进行递归查询CDN：DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容dns-prefetch：DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。获得请求 url 对应的 ip 地址，根据解析到的 IP 地址和端口号发起请求建立 TCP 连接：tcp 协议通过三次握手与服务器建立连接服务器（nginx、apache 等）处理请求并返回 HTTP 报文，浏览器收到开始渲染渲染过程参考：https://juejin.cn/post/6844903779700047885浏览器根据深度遍历的方式把 html 节点遍历成 dom 树将 css 解析成 CSS DOM 树将 dom 树和 CSS DOM 树构造成渲染树补充：构造渲染树的过程，从 DOM 树的根节点开始遍历每个可见的节点，对于每个可见的节点，找到 CSS 树中的对应的规则，并且应用他们，根据每个可见的节点及其对应的样式，组合生成渲染树当文档加载过程中遇到 js 文件，html 文档会挂起渲染的线程，要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，这意味着在 JS 执行完成前，后续资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的根据得到的渲染树，计算所有节点在屏幕中的位置，进行布局（回流）遍历渲染树并调用硬件的 API 绘制所有节点（重绘）断开 TCP 连接：TCP 四次挥手script、css 标签，会不会阻塞 DOM 渲染？CSS 不会阻塞 DOM 解析，但是会阻塞 DOM 渲染，严谨一点则是 CSS 会阻塞 render tree 的生成，进而会阻塞 DOM 的渲染DOM 树和 CSSOM 树的解析是互不影响的，因此 css 不会阻塞页面的解析但是由于 render 树的生成是依赖 DOM 树和 CSSOM 树，因此 CSS 必然会阻塞 DOM 的渲染css 会阻塞 rrender 树的生成，进而会阻塞 dom 的渲染JS 会阻塞 DOM 解析CSS 会阻塞 JS 的执行如果 js 脚本中是获取 dom 元素的 css 样式属性，为了获取到最新的正确的样式，需要所有的 css 加载完成，否则获取的样式可能是错误的或者不是最新的要等到 js 脚本前面的 css 加载完成，js 才能再执行所以一般 cdn 引入第三方库的 script 一般放在 link 之前浏览器遇到 &lt;script&gt; 标签且没有 defer 或 async 属性时会触发页面渲染Body 内部的外链 CSS 较为特殊，会形成样式闪烁现象，请慎用Web Worker现代浏览器为 JavaScript 创造的 多线程环境。可以新建并将部分任务分配到 worker 线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。 基本用法：// 创建workerconst worker = new Worker(&#x27;work.js&#x27;);// 向 worker 线程推送消息worker.postMessage(&#x27;Hello World&#x27;);// 监听 worker 线程发送过来的消息worker.onmessage = function (event) {  console.log(&#x27;Received message &#x27; + event.data);};限制:同源限制无法使用 document / window / alert / confirm无法加载本地资源XSS、CSRF 攻击原理和防御XSS：通过利用网页开发时留下的漏洞，比如评论框，注入恶意 js 到网页防御 xss：过滤 html 标签，转义页面上的输入内容和输出内容，过滤 on 开头属性，cookie 设置 httpOnlyCSRF：设法伪造带有正确 Cookie 的 HTTP 请求通常由于服务端没有对请求头做严格过滤引起的CSRF 防御：不要使用 GET 请求来修改数据不要被第三方网站访问到用户的 cookieReferer 头检测，设置白名单接口不要被第三方网站请求、用 token 请求校验SameSite是 cookie 的一个属性，用来防止 CSRF 攻击和用户追踪，用来限制第三方 CookieStrict完全禁止第三方 Cookie，可能造成不好的用户体验，比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态Lax（默认值）大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外None网站可以选择显式关闭 SameSite 属性，将其设为 None。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。DOM api创建新节点createDocumentFragment() //创建一个 DOM 片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入查找getElementsByTagName()getElementsByName()getElementById()document.querySelector()document.querySelectorAll()前端路由原理hash 模式：在浏览器中，#号以及#号后面的字符称之为 hash，用 window.location.hash 读取hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，修改 hash 不会刷新页面hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误原理大概是监听 onhashchange 事件执行对应回调history 模式：history 采用了 HTML5 的新特性 pushState 和 replaceState 可以对浏览器历史记录、html 标题进行修改，监听 popState 事件执行对应回调history 模式下，前端的 URL 和实际向后端发起请求的 URL 一致。服务端如果缺少对该页面请求的处理，就会返回 404 错误需要服务器的支持：需要在服务端增加一个覆盖所有情况的候选资源：比如 URL 匹配不到任何资源时，则返回同一个 index.html 页面，这个页面就是前端应用的入口页面个人更推荐用 history 模式，history 模式更利于 seo 优化，url 也比较美观什么是 HTML 语义化HTML5 语义化标签是指：正确的标签包含正确的内容，结构良好，便于阅读，利于 SEO 优化，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签单页应用（SPA）优缺点优点：内容的改变不需要重新加载整个页面，用户体验好相对对服务器压力小前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理缺点：首屏加载慢前进后退路由需要自己管理，不能使用浏览器的前进后退功能SEO（搜索优化）难度大白屏如何解决白屏问题往 html 中填充内容，比如渲染根元素中间加上“加载中”几个字，让渲染结束前的这段时间有内容可以显示计算首屏白屏时间使用 Performance API：&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;白屏&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      // 不兼容performance.timing 的浏览器，如IE8      window.pageStartTime = Date.now();    &lt;/script&gt;    &lt;!-- 页面 CSS 资源 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot; /&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      // 白屏时间结束点      window.firstPaint = Date.now();    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 页面内容 --&gt;  &lt;/body&gt;&lt;/html&gt;可使用 Performance API 时，白屏时间 = firstPaint - performance.timing.navigationStart;不可使用 Performance API 时，白屏时间 = firstPaint - pageStartTime;手写 Ajaxvar xhr = new XMLHttpRequest();xhr.onreadystatechange = function () {  // 通信成功时，状态值为4  if (xhr.readyState === 4) {    if (xhr.status === 200) {      console.log(xhr.responseText);    } else {      console.error(xhr.statusText);    }  }};xhr.onerror = function (e) {  console.error(xhr.statusText);};xhr.open(&#x27;GET&#x27;, &#x27;http://www.example.com/page.php&#x27;, true);xhr.send(null);XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。0，表示 XMLHttpRequest 实例已经生成，但是实例的 open()方法还没有被调用。1，表示 open()方法已经调用，但是实例的 send()方法还没有调用，仍然可以使用实例的 setRequestHeader()方法，设定 HTTP 请求的头信息。2，表示实例的 send()方法已经调用，并且服务器返回的头信息和状态码已经收到。3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。同源策略（跨域）不同协议、域名、端口，禁止请求，iframe、image、script、link 标签可以为什么会有同源策略如果没有同源策略，不同源的数据和资源（如 HTTP 头、Cookie、DOM、localStorage 等）就能相互随意访问，根本没有隐私和安全可言。解决nginx，tomcat，apache 等任何有代理相关功能的服务器jsonpcorsjsonp使用 script 标签来帮助我们跨域服务端返回 函数名({json数据})，放在 script src 请求执行，前后端约定好函数名（或者由前端传给后端，即 callbackName）jquery 封装了 jsonp缺点：不好调试，在调用失败的时候不会返回任何状态码安全性，提供 jsonp 的服务可能存在页面注入漏洞cors服务器设置响应头：Access-Control-Allow-Origin:&lt;origin&gt;|*，origin 参数的值指定了允许访问该资源的外域 URL默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DRP、DownLink、Save-Data、Viewport-Width、Width、Content-Type(值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一)如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求失败res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type,X-Custom-Header&#x27;);默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求，如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法// 只允许POST、GET、DELETE、HEAD请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST,GET,DELETE,HEAD&#x27;);// 允许所有的HTTP请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;);请求的分类同时满足以下两大条件的请求，就属于简单请求，反之为非简单请求：请求方式：GET、POST、HEAD 三者之一HTTP 头部信息不超过以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain简单请求：请求头自动带上 Origin如果 Origin 指定的源不在允许范围之内，服务器就会返回一个正常的 HTTP 回应，然后浏览器发现头信息中没有包含 Access-Control-Allow-Origin 字段，就表示出错否则会出现如下响应头Access-Control-Allow-Origin: http://api.bob.com # 接受请求的域(*为所有)Access-Control-Allow-Credentials: true # 是否可以发送cookieAccess-Control-Expose-Headers: FooBar # 该字段可选，XHMHttpRequest 对象的方法只能够拿到六种字段: Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果想拿到其他的需要使用该字段指定Content-Type: text/html; charset=utf-8如果请求时需要带上 cookie，请求头需要设置 withCredentials 为 true非简单请求：非简单请求的 CORS 会在正式通信之前进行一次预检请求浏览器先询问服务器，当前网页所在的域名是否可以请求您的服务器，以及可以使用那些 HTTP 动词和头信息，只有得到正确的答复，才会进行正式的请求预检使用的请求方法是 OPTIONS，表示这个请求是用来询问的# 预检请求示例OPTIONS /cors HTTP/1.1Origin: localhost:2333Access-Control-Request-Method: PUT // 表示使用的什么HTTP请求方法Access-Control-Request-Headers: X-Custom-Header // 表示浏览器发送的自定义字段Host: localhost:2332Accept-Language: zh-CN,zh;q=0.9Connection: keep-aliveUser-Agent: Mozilla/5.0...服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应# 预检响应头示例HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://localhost:2332 // 表示 http://localhost:2332可以访问数据Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain如未通过预检，会返回一个正常的 HTTP 响应，但是没有任何 CORS 的头相关信息，浏览器认定为失败当预检请求通过之后就发出正常的 HTTP 请求事件流事件流描述的是从页面中接收事件的顺序，事件流包括下面几个阶段。事件捕获阶段处于目标阶段事件冒泡阶段addEventListener 第三个参数：true - 事件在捕获阶段执行；false（默认） - 事件在冒泡阶段执行事件流的应用：事件委托（事件代理）事件委托指的是，不直接在目标 dom 上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。举例：ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。target 和 currentTarget 区别event.target 返回触发事件的元素event.currentTarget 返回绑定事件的元素事件冒泡如果一个元素触发事情，那么其所有祖先元素都会依次执行触发该事件，这种机制称为冒泡（好比气泡从水底下一直向上冒泡，像 dom 树一样，一直到根元素。）事件捕获捕获与事件冒泡刚好相反如何取消事件冒泡在通常情况下，我们只希望事件发生在它的目标而并非它的父级元素上，封装 stopBubble 方法如下// 阻止事件冒泡的通用函数function stopBubble(e) {  // 如果传入了事件对象，那么就是非ie浏览器  if (e &amp;&amp; e.stopPropagation) {    // 因此它支持W3C的stopPropagation()方法    e.stopPropagation();  } else {    // 否则我们使用 ie 的方法来取消事件冒泡    window.event.cancelBubble = true;  }}a.onclick = function (e) {  stopBubble(e);};js 的各种位置区别clientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border 和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。localStorage、sessionStorage关闭选项卡后，将删除存储在 sessionStorage 中的数据localStorage 永远存在，除非手动删除cookie 根据 expires 字段（过期时间）决定"},{"id":"前端技术\\浏览器\\浏览器架构.md","filename":"浏览器架构.md","basename":"浏览器架构","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\浏览器","relative_path":"前端技术\\浏览器","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\浏览器","content":"参考：https://juejin.cn/post/6844904046411644941https://zhuanlan.zhihu.com/p/149063367浏览器架构（以 chrome 为例）各个进程以及负责的工作chrome 采用多进程架构Browser（主进程）浏览器界面显示，用户交互，前进、后退、收藏前进和后退按钮同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写协调控制其他子进程（创建、销毁）Plugin控制网页使用的所有插件，例如 flash 插件每种类型的插件对应一个进程，仅当使用该插件时才创建GPU3D 绘制，负责独立于其它进程的 GPU 任务。它之所以被独立为一个进程是因为它要处理来自于不同 tab 的渲染请求并把它在同一个界面上画出来Renderer（渲染进程），最重要渲染进程，即浏览器内核这就是主要与前端开发打交道的进程，负责页面渲染，脚本执行，事件处理等负责 tab 内和网页展示相关的所有工作。Chrome 会尽可能为每一个 tab 甚至是页面里面的每一个 iframe 都分配一个单独的渲染进程渲染进程渲染进程包含几大类子线程：GUI 渲染线程负责渲染页面，布局和绘制页面需要重绘和回流时，该线程就会执行与 js 引擎线程互斥，防止渲染结果不可预期JS 引擎线程负责处理解析和执行 javascript 脚本程序只有一个 JS 引擎线程（单线程）与 GUI 渲染线程互斥，防止渲染结果不可预期事件触发线程用来控制事件循环当事件满足触发条件时，将事件放入到 JS 引擎所在的执行队列中定时器线程setInterval 与 setTimeout 所在的线程定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的计时完毕后，通知事件触发线程异步网络请求线程浏览器有一个单独的线程用于处理 AJAX 请求当请求完成时，若有回调函数，通知事件触发线程其中 GUI 线程和 JS 引擎线程是互斥的，由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致一个 tab 一个渲染进程的优缺点优点：提供安全性和沙盒性，当其中一个 tab 的崩溃时，你可以随时关闭这个 tab 并且其他 tab 不受到影响缺点：内存消耗大网站隔离功能会为网站内不同站点的 iframe 分配一个独立的渲染进程由来：如果一个 tab 只有一个进程的话不同站点的 iframe 都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略常见浏览器内核IE：Trident 内核，也是俗称的 IE 内核Chrome：以前是 Webkit 内核，现在是 Blink 内核Firefox：Gecko 内核苹果 Safari：Webkit 内核"},{"id":"前端技术\\浏览器\\浏览器缓存.md","filename":"浏览器缓存.md","basename":"浏览器缓存","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\浏览器","relative_path":"前端技术\\浏览器","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\浏览器","content":"参考https://www.jianshu.com/p/54cc04190252浏览器缓存Web 缓存种类： 数据库缓存，CDN 缓存，服务器缓存（例如 redis），浏览器缓存浏览器实现了 http 缓存浏览器缓存类型：强缓存，协商缓存只有 get 请求会缓存，post 请求不会缓存位置Memory Cache内存中缓存主要包含的是当前页面中已经抓取到的资源，已经下载的样式、脚本、图片读取高效、持续性很短随着进程的释放而释放，杀进程或者关闭 Tab 页面会被释放对于大文件来说，大概率是不存储在 Memory Cache 的，反之优先Disk Cache磁盘缓存浏览器获取当前系统内存使用率，过高的话，优先存储进 Disk Cache所有类型资源都可以放速度较慢不会被释放容量大缓存过程首次请求：总体大致流程：强缓存当符合命中强缓存的条件，不向服务器发送请求，直接从缓存中读取资源，返回 200 状态码如果响应头有如下字段（按优先级小到大排序）：expires &lt; pragma &lt; cache-control，则为强缓存cache-control 优先级最高，当不支持 http1.1 的环境才会使用 expires 或者 pragmaexpires资源到期时间、格式为格林尼治时间戳如果未超过过期时间，直接使用该缓存缺点：要求客户端和服务端时钟严格同步，本地时间可以自己修改pragmaHTTP 1.0用于禁用网页缓存取值为 no-cache，和 cache-control 的 no-cache 效果一样cache-controlHTTP 1.1 新增取值public：资源客户端和服务器都可以缓存privite：资源只有客户端可以缓存no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证no-store：不使用缓存max-age：缓存保质期协商缓存强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程会向服务器发送请求协商缓存过程服务器发现资源无需更新，返回 304浏览器从本地缓存中获取资源，继续使用如果服务器发现该资源更新了，返回该资源，状态码 200浏览器更新该资源和缓存标识到本地缓存相关 headerLast-Modified / If-Modified-Since存在的问题：时间单位只精确到秒，如果文件 1 秒内改变多次，无法确保缓存精度；有可能文件内容没变，但是修改时间因为某些原因变了，人为修改之类的Last-Modified（响应头）资源在服务器最后被修改的时间If-Modified-Since（请求头）携带上次请求返回的 Last-Modified告诉服务器该资源上次请求时的最后被修改时间服务器做对比后决定协商缓存是否生效，返回 304 或 200Etag / If-None-Match优先级高于 Last-Modified，解决 Last-Modified 的问题，但性能比 Last-Modified 差，Etag 需要计算Etag（响应头）当前资源文件唯一标识，由服务器生成，由文件内容决定If-None-Match（请求头）携带上次请求该资源时返回的 Etag，告诉服务器服务器做对比，一致则代表生效，返回 304 或 200实际应用需要实时更新频繁变动的资源，设置 cache-control 为 no-cache不常变化的资源，例如 jquery，设置 cache-control 为 max-age=一个很长的时间单页应用部署时，入口 html 文件使用协商缓存（确保 html 入口是最新的，能够及时更新）按下 F5 或 ctrl+F5 时发生了什么ctrl+f5：跳过强缓存和协商缓存，直接从服务器加载资源f5：跳过强缓存，会检查协商缓存浏览器地址栏中输入 URL 回车：走正常流程"}]},{"id":"前端技术\\React","dirname":"React","filename":"","basename":"","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","children":[{"id":"前端技术\\React\\Fiber.md","filename":"Fiber.md","basename":"Fiber","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\React","relative_path":"前端技术\\React","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\React","content":"Fiber是 React 核心算法的重新实现，是 React 团队两年多研究的结晶，是对 reconciliation 的重新编写，重新实现了 reconciler（协调器）目标是提高其对动画、布局和手势等领域的适用性允许将更新分解成更小的任务，达到增量渲染，将渲染工作拆分为块并将其分散到多个帧上，更新不会长时间阻止主线程（比如用户输入，动画之类）其他主要功能包括能够在新更新到来时暂停，中止或重用工作注意：并不会减少总工作量或更新所需的时间为什么 Fiber旧版 React 在处理 UI 时，使用栈递归遍历树结构，整个过程同步无法被打断，如果树结构太大层级很深，会一直占用浏览器主线程，可能导致动画丢帧，看起来断断续续（JS 线程和 GUI 线程是互斥的）改变了之前 react 的组件渲染机制，新的架构使原来同步渲染的组件可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程，保证任务在浏览器空闲的时候执行Fiber 架构思想浏览器现有 api：requestIdleCallback （闲时调用）来实现异步渲染，但 React 为了照顾绝大多数的浏览器，自己实现了 requestIdleCallback两个阶段：Reconciliation 与 Commit。Reconciliation 阶段对应早期版本的 diff 过程，Commit 阶段对应早期版本的 patch 过程，以 render 为界阶段一（Reconciliation）：生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率阶段二（Commit）：需要更新的节点一次过批量更新，这个过程不能被打断Reconciliation 如果遇到更高优先级事件，则进行打断，渲染到一半的组件，会从头开始渲染，在 Reconciliation 阶段，一些生命周期可能会重新执行，例如componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate这些生命周期函数则会在 Commit 阶段调用componentDidMountcomponentDidUpdatecomponentWillUnmountFiber 树React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复workInProgress Fiber 树在 React 中最多会同时存在两棵 Fiber 树，当前显示在页面是 current Fiber 树，在内存中构建的 Fiber 树称为 workInProgress Fiber 树，workingProgress Fiber 这棵树是在内存中构建的，构建完成才统一替换，这样不会产生不完全的真实 dom。一旦更新完成，react 会直接将 current 树替换成 workingProgress Fiber 树，以便快速完成 DOM 的更新。也是 react 提升性能的一部分Fiber 数据结构interface FiberNode {  stateNode: any; // 节点实例  child: any; // 子节点  sibling: any; // 兄弟节点  return: any; // 父节点}Fiber 为什么使用链表React 使用单链表树遍历算法实现在没有递归的情况下遍历树，树形结构并不满足中途暂停对异步友好，它使暂停遍历并使阻止堆栈增长成为可能目前的虚拟 DOM 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行，所以需要一种新的数据结构，即链表，链表可以包含多个指针，可以轻易找到下一个节点，继而恢复任务的执行Fiber 采用的链表中包含三个指针，parent 指向其父 Fiber 节点，child 指向其子 Fiber 节点，sibling 指向其兄弟 Fiber 节点。一个 Fiber 节点对应一个任务节点Fiber 为什么深度优先查找 context 的消费节点，当 context 改变之后, 需要找出依赖该 context 的所有子节点"},{"id":"前端技术\\React\\Hooks.md","filename":"Hooks.md","basename":"Hooks","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\React","relative_path":"前端技术\\React","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\React","content":"参考https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/为什么 hooks类组件的性能消耗比较大，因为类组件需要创建类组件的实例，而且不能销毁函数式组件性能消耗小，因为函数式组件不需要创建实例，渲染的时候就执行一下，得到返回的 react 元素后就直接把中间量全部都销毁复用状态逻辑：Hook 使你在无需修改组件结构的情况下复用状态逻辑，可以将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，在组件之间复用状态逻辑很难，如果要增加职责的话，就要加一层 HOC，容易形成“嵌套地狱”，一个套一个复杂 class 组件会变得难以理解，比如 componentDidMount 和 componentWillUnmount 是区分开的，Hook 可以将组件中相互关联的部分拆分成更小的函数class 比普通函数更难理解和使用，尤其是 this代码组织上，hooks 将业务逻辑聚合后，整个工程可阅读性大大增加友好渐进式的，项目中可以同时使用 class 和 hooksvue 中 mixin 的缺点难以追溯的方法与属性（不知道这个属性或方法是谁的）hook 为什么不能放在循环、条件、嵌套函数执行（为什么顺序调用对 React Hooks 很重要？）Not Magic, just ArraysHook 通过数组实现的，每次 useState 都会改变下标，React 需要利用调用顺序来正确更新相应的状态，否则会引起调用顺序的错乱，从而造成意想不到的错误能确保 Hook 在每一次渲染中都按照同样的顺序被调用，让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确React 依靠 Hook 调用的顺序来知道哪个 state 对应哪个 useState，Hook 的调用顺序在每次渲染中都是相同的，只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联Hook 需要在我们组件的最顶层调用Hooks 重渲染时是依赖于固定顺序调用，来保证被正确识别，依赖数组来维护，有一个 setter 数组和一个索引，该索引在每个 hooks 被调用时递增，并在组件 render 时重置用数组解构语法来命名 useState() 返回的 state 变量，但这些变量不会连接到 React 组件上，数据的存储是独立于组件之外的步骤初始化：创建两个空数组 setters 与 states，创建一个指针设置为 0首次渲染：每当 useState() 被调用时，如果它是首次渲染，它会通过 push 将一个 setter 方法（绑定了指针“cursor”位置）放进 setters 数组中，同时，也会将另一个对应的状态放进 states 数组中去后续渲染：每次的后续渲染都会重置指针“cursor”的位置，并会从每个数组中读取对应的值处理设置事件：每个 setter 对应一个指针位置的引用，当触发任何 setter 调用的时候，会去改变状态数组中对应索引的值开发工作中可以使用 eslint 配置相关规则发现这一错误hooks 实现为什么用数组不用 map使用 key 值取映射 hook 的话，自定义的 hook 被多个组件调用的话，很难不保证之前有没有同名的 key 在其他组件内用 Symbol：不能很好地复用了，因为 key 值的唯一性使得总是同一个 key 调用了 hookReact 如何区分 Class 组件和 Function 组件假设这个类叫 Greetinginstanceof 检查 Greeting 是否是 React.Component 的继承类检查 Greeting.prototype.isReactComponent 属性hooks 特性Effect 拿到的总是定义它的那次渲染中的 props 和 state，在任意一次渲染中，props 和 state 是始终保持不变的，它们都属于一次特定的渲染，同样，每次渲染都有它自己的 Effects可通过 ref 来保存值，实现在所有的渲染帧中共享React 会记住我们设置的 effect 函数，并且会在每次 DOM 更改后、浏览器绘制屏幕后，去调用，这使得应用更流畅，不会阻塞屏幕的更新，上一次的 effect 会在重新渲染后被清除依赖项不要对 React 撒谎：effect 中用到的所有组件内的值都应该包含在依赖中可以使用 setState 的函数形式，获取上一次调用对应 setter 时传的状态值如果某些函数仅在 effect 中调用，可以把它们的定义移到 effect 中，这样可以不再需要去考虑依赖如果一个函数没有使用组件内的任何值，可以把它提到组件外面去定义成纯函数，然后就可以自由地在 effects 中使用（或者把它包装成 useCallback）useEffect 第一个参数，不能返回 Promise，所以不能传递异步函数，可以自己在里面声明再执行定时器的例子// 先点击 alert，再点击几次 add 增加 count，3 秒后弹出的是点击 alert 时的状态function Counter() {  const [count, setCount] = useState(0);  function handleAlertClick() {    setTimeout(() =&gt; {      alert(&#x27;You clicked on: &#x27; + count);    }, 3000);  }  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;add&lt;/button&gt;      &lt;button onClick={handleAlertClick}&gt;alert&lt;/button&gt;    &lt;/div&gt;  );}// 而如果是在类组件中，则会正确弹出状态的当前值// 因为类组件的状态保存在实例属性上，状态改变实例不会销毁hooks 缺点响应式的 useEffect 写函数组件时，你不得不改变一些写法习惯。你必须清楚代码中 useEffect 和 useCallback 的“依赖项数组”的改变时机。有时候，你的 useEffect 依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链。一旦这条依赖链的某个节点意外地被改变了，你的 useEffect 就被意外地触发了过度使用 useMemo 后果useMemo 本身也有开销useMemo 会「记住」一些值，同时在后续 render 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源如果你执行的操作开销不大，那么你就不需要记住返回值。使用 useMemo 的成本可能会超过重新评估该函数的成本使用前应该先思考三个问题：传递给 useMemo 的函数开销大不大返回的值是原始值吗，如果计算出来的是基本类型的值（string、 boolean 、null、undefined 、number、symbol），那么每次比较都是相等的，下游组件就不会重新渲染；如果计算出来的是复杂类型的值（object、array），哪怕值不变，但是地址会发生变化，导致下游组件重新渲染。所以我们也需要「记住」这个值。在编写自定义 Hook 时，返回值一定要保持引用的一致性。 因为你无法确定外部要如何使用它的返回值。如果返回值被用做其他 Hook 的依赖，并且每次 re-render 时引用不一致（当值相等的情况），就可能会产生 bug。所以如果自定义 Hook 中暴露出来的值是 object、array、函数等，都应该使用 useMemo 。以确保当值相同时，引用不发生变化。hooks 常用 APIuseCallback：返回一个记忆函数，缓存了每次渲染时那些回调函数的实例，可以配合 React.memo 起到减少不必要的渲染的作用useMemo：返回一个记忆值，传递一个工厂函数和数组。useMemo 只会在数组其中一个输入发生更改时重新调用工厂函数去计算这个值。此优化有助于避免在每个渲染上进行高开销的计算。useRef：useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传递的参数（initialValue）。返回的对象将存留在整个组件的生命周期中。useRef 在 react hook 中的作用, 正如官网说的, 它像一个变量, 类似于 this , 它就像一个盒子, 你可以存放任何东西. createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用useImperativeHandle：自定义使用 ref 时公开给父组件的实例值，往往与 forwardRef 一起使用useLayoutEffect：签名与 useEffect 相同，但在所有 DOM 变化后同步触发Hook 使用规则和注意约定以 use 开头并且紧跟大写字母（因为约定的力量在于：我们不用细看实现，也能通过命名来了解一个它是什么）只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook，能确保 Hook 在每一次渲染中都按照同样的顺序被调用只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook，确保组件的状态逻辑在代码中清晰可见（Eslint 通过判断一个方法是不是大坨峰命名来判断它是否是 React 函数）自定义 hooks自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。自定义 Hook 必须以 “use” 开头，不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的使用规则在两个组件中使用相同的 Hook 不会共享 state，自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的useEffect 为什么不能传入异步函数理由是 effect function 应该返回一个销毁函数（effect：是指 return 返回的 cleanup 函数），如果 useEffect 第一个参数传入 async，返回值则变成了 Promise，会导致 react 在调用销毁函数的时候报错：function.apply is undefined为什么这样设计useEffect 的返回值是要在卸载组件时调用的，React 需要在 mount 的时候马上拿到这个值，不能有延迟解决使用 IIFE 或者声明异步函数再执行，推荐使用 IIFE 写法，因为声明的异步函数可能有外部依赖无法及时更新useEffect(() =&gt; {  (async () =&gt; {    const res = await fetch(SOME_API);    setValue(res.data);  })();}, []);编写自定义 hook useAsyncEffect// 自定义hookfunction useAsyncEffect(effect: () =&gt; Promise&lt;void | (() =&gt; void)&gt;, dependencies?: any[]) {  return useEffect(() =&gt; {    const cleanupPromise = effect();    return () =&gt; {      cleanupPromise.then((cleanup) =&gt; cleanup &amp;&amp; cleanup());    };  }, dependencies);}// 使用useAsyncEffect(async () =&gt; {  const count = await fetchData();  setCount(count);}, [fetchData]);useEffect 实现防抖useEffect(() =&gt; {  const timer = setTimeout(async () =&gt; {    await fetchData(deps);  }, 500);  return () =&gt; clearTimeout(timer);}, [deps]);不能直接向 useEffect 传递防抖函数，因为 useEffect 常依赖 props 或者 useState 返回的值，当两种值改变后，都会触发 Function 组件重新渲染，那么 useEffect 又会重新执行一遍，生成一个新的防抖后的函数"},{"id":"前端技术\\React\\React.md","filename":"React.md","basename":"React","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\React","relative_path":"前端技术\\React","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\React","content":"React渲染原理虚拟 dom使用 javascript 对象表示 DOM 结构的树形数据结构这个树结构包含整个 DOM 结构的信息真实 DOM 的内存表示，一种编程概念为框架带来了跨平台的能力，抽象了原本的渲染过程，实现了跨平台的能力结合 diff 算法，可以减少 JavaScript 操作真实 DOM 的带来的性能消耗虚拟 dom 优势：直接操作/频繁操作 DOM 的性能差虚拟 DOM 不会立马进行排版与重绘操作虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部key 的作用Keys 是一个辅助标识，用于追踪列表中被修改的元素在 diff 算法中，会借助元素的 key 值来判断该元素是不是新创建的，而减少不必要的重新渲染reconciliation（协调）当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。当一个组件更新时，组件实例会保持不变，因此可以在不同的帧保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 componentWillReceiveProps()、componentWillUpdate()、componentDidUpdate()当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素，使得树的转换效率得以提高Key 应该具有稳定，可预测，以及列表内唯一的特质，不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢diff 过程比对新老虚拟 dom 的变化，然后将变化的部分更新到视图上把树形结构按照层级分解，只比较同级元素给列表结构的每个单元添加唯一的 key 属性，方便比较对比不同类型的元素对比同一类型的元素对比同类型的组件元素对子节点进行递归为什么有 diff在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。diff 为什么不能用下标当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动Refs通过 ref，允许访问 dom不得不直接访问时才使用，否则容易造成混乱Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例。Hooks 中的 useRef 可以用来保存多帧共享数据React 常用 apiReact.PureComponent：React.PureComponent 与 React.Component 完全相同，但是在 shouldComponentUpdate() 中实现时，使用了 props 和 state 的浅比较，可以提高性能React.memo：是一个高阶组件，与 React.PureComponent 类似，但是他用于包裹函数式组件，而不是类组件；如果函数式组件在给定相同的 props 的情况下渲染相同的结果，你可以在调用 React.memo 将其包装起来，以便在某些情况下通过记忆结果来提高性能。 这意味着 React 将跳过组件渲染，并重用最后渲染的结果。React.createRef：创建一个 ref ，它可以通过 ref 属性附加到 React 元素React.forwardRef：创建一个 React 组件，将它接收的 ref 属性转发给组件树中的另一个组件。接受渲染函数作为参数。React 将用 props 和 ref 作为两个参数来调用这个函数。此函数应返回 React 节点React.lazy：定义动态加载的组件。有助于减少包大小，以延迟加载在初始渲染期间未使用的组件，要求被&lt;React.Suspense&gt;组件包裹。这是指定加载指示器的方式React.Suspense：指定加载指示器异步加载使用示例：const Box = React.lazy(() =&gt; import(&#x27;./components/Box&#x27;));&lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;{show &amp;&amp; &lt;Box /&gt;}&lt;/Suspense&gt;;import()es2020 的规范import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式webpack 碰到之后会将其拆出来成一个 chunk，可以使用魔术注释自定义 chunk 名称，需要加载时会通过异步请求来加载这个 chunk对应的 babel 语法插件：https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/#installationPureComponent 的陷阱PureComponent 创建了默认的 shouldComponentUpdate 行为，这个默认的 shouldComponentUpdate 行为会一一比较 props 和 state 中所有的属性，只有当其中任意一项发生改变是，才会进行重绘PureComponent 使用浅比较判断组件是否需要重绘，即比较指针的异同所以如果 props 和 state 是引用对象，比如对象、数组，修改属性或元素，不会导致重绘React 异常处理设置编边界包裹组件，实现 componentDidCatch为什么不要在 render 中 setState？会造成死循环为什么不要在 render 中声明组件不要在 render 中声明组件，不然每次渲染都是声明的一个新的组件，组件的一些非受控状态就会丢失，比如聚焦状态，浏览器选中文字状态实现组件之间代码重用，为什么推荐组合、HOC，而不是继承React 希望组件是按照最小可用的思想来进行封装，就是一个组件只做一件的事情，这叫单一职责原则函数式编程中，函数组合是组合两个或多个函数以产生新函数的过程。将函数组合在一起就像将一系列管道拼接在一起，让我们的数据流过setStatesetState 如何深合并方法一：使用展开运算符方法二：先直接赋值，再调一次 setState({})setState 时发生了什么将传递给 setState 的对象合并到组件的当前状态。构建一个新的虚拟 dom。将新树与旧数比较，计算出新旧树的节点差异，确定需要更新的真实 dom。调用 render 方法更新 UI。setState 什么时候异步什么时候同步与调用时的环境相关在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState 是“异步”的，如果需要马上同步去获取新值，setState 可以传入第二个参数，在回调中即可获取最新值在 原生事件 和 setTimeout 中，setState 是同步的，可以马上获取更新后的值原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.statesetState 在 react 生命周期和合成事件会批量覆盖执行当遇到多个 setState 调用的时候会提取单次传递 setState 对象，将它们进行合并（类似 Object.assign，遇到相同 key 会覆盖前面的 key）setState 在原生事件，setTimeout、setInterval、promise 等异步操作中，state 会同步更新所谓合成事件就是：react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange 这些都是合成事件批量更新机制在 合成事件 和 生命周期钩子 中，setState 更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新函数型式由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在 fn 中返回新的 state 对象即可，例如 this.setState((state, props) =&gt; newState)；使用函数型式，可以用于避免 setState 的批量更新的逻辑，传入的函数将会被 顺序调用注意事项setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次当组件已被销毁，如果再次调用 setState，React 会报错警告，通常有两种解决办法：将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount 中标记为 true，在 setState 前进行判断单向数据流规定数据只能由外层组件向内层组件进行传递和更新。组件的 props 是只读的。否则容易导致数据紊乱、出现不可控操作。让组件之间的关系变得简单、可预测。如果数据在兄弟子组件之间共享，那么数据应该存储在父组件，并同时传递给需要数据的两个子组件。高阶组件（HOC）高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的增强组件。高阶组件自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式和编程技巧。常见的有 react-redux 里的 connect 和 react-router 中的 withRouter。作用：复用组件逻辑，操作状态和参数，渲染劫持场景和应用：权限控制性能监控，包裹组件的生命周期，进行统一埋点日志打点双向绑定可以借助 ES7 提供的 Decorators （装饰器）来让写法变得优雅，安装并配置 babel 插件：babel-plugin-transform-decorators-legacy使用注意：不要在 render 方法内创建高阶组件，会导致组件每次都会被卸载后重新挂载不要改变原始组件，高阶组件应该是没有副作用的纯函数，这样破坏了对高阶组件的约定，也改变了高阶组件的初衷，使用高阶组件是为了增强而非改变生命周期1、挂载卸载过程constructor() 必须写super(),否则会导致this指向错误componentWillMount() 即将过时不要使用componentDidMount() dom节点已经生成，可以在这里调用ajax请求componentWillUnmount() 在这里移除事件订阅和定时器2、更新过程componentWillReceiveProps(nextProps) 即将过时不要使用，接受父组件改变后的props需要重新渲染shouldComponentUpdate(nextProps,nextState) 性能优化componentWillUpdate(nextProps,nextState) 即将过时不要使用componentDidUpdate(prevProps,prevState)render() 插入jsx生成的dom结构，diff算法比较更新前后的新旧DOM树，找到最小的有差异的节点，重新渲染在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误新版的建议生命周期如下：class Component extends React.Component {  // 替换 `componentWillReceiveProps`  // 初始化和 update 时被调用  // 静态函数，无法使用 this  static getDerivedStateFromProps(nextProps, prevState) {}  // 判断是否需要更新组件  // 可以用于组件性能优化  shouldComponentUpdate(nextProps, nextState) {}  // 组件被挂载后触发  componentDidMount() {}  // 替换  componentWillUpdate;  // 可以在更新之前获取最新 dom 数据  getSnapshotBeforeUpdate() {}  // 组件更新后调用  componentDidUpdate() {}  // 组件即将销毁  componentWillUnmount() {}  // 组件已销毁  componentDidUnmount() {}}生命周期使用建议：在 constructor 初始化 state在 componentDidMount 中进行事件监听，并在 componentWillUnmount 中解绑事件在 componentDidMount 中进行数据的请求，而不是在 componentWillMount需要根据 props 更新 state 时，使用 getDerivedStateFromProps(nextProps, prevState)可以在 componentDidUpdate 监听 props 或者 state 的变化在 componentDidUpdate 使用 setState 时，必须加条件，否则会死循环getSnapshotBeforeUpdate(prevProps, prevState) 可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前shouldComponentUpdate: 默认每次调用 setState，一定会最终走到 diff 阶段，但可以通过 shouldComponentUpdate 的生命钩子返回 false 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能react 性能优化是哪个周期函数shouldComponentUpdate这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘比较消耗性能，如果能在 shouldComponentUpdate 方法中能够写出更优化的逻辑，可以提高性能。React 中的事件处理为了解决跨浏览器兼容性问题，React 会将 浏览器原生事件 封装为 合成事件 传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，它屏蔽了底层浏览器的细节差异，保证了行为的一致性。React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层（document）进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。react 合成事件是什么，和原生事件的区别React 合成事件机制，React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，然后 React 将事件封装给正式的函数处理运行和处理如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，React 实现了一个中间层当用户在为 onClick 添加函数时，React 并没有将 Click 事件绑定在 DOM 上面，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层constructor 中 super 与 props 参数一起使用的目的是什么是 ES6 规定的，在子类的 constructor 中必须先调用 super 初始化父类才能引用 this。在调用方法之前，子类构造函数无法使用 this 引用 super() 。什么是受控组件受控：value 和 state 绑在一起的。非受控：可通过浏览器 api 获取值。为什么一定要 import “react”JSX 实际上是 React.createElement 的语法糖，jsx 会被 babel 翻译成 React.createElementreact 性能优化方案重写 shouldComponentUpdate 来避免不必要的 dom 操作。使用 production 版本的 react.js。使用 key 来帮助 React 识别列表中所有子组件的最小变化。React.memoPureComponentuseMemo、useCallbackContext当不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现 跨层级 的组件数据传递React.createContext：创建一个上下文的容器(组件), defaultValue 可以设置共享的默认数据Provider(生产者): 和他的名字一样。用于生产共享数据的地方。生产什么呢？ 那就看 value 定义的是什么了。value:放置共享的数据Consumer(消费者):这个可以理解为消费者。 他是专门消费供应商(Provider 上面提到的)产生数据。Consumer 需要嵌套在生产者下面。才能通过回调的方式拿到共享的数据源。当然也可以单独使用，那就只能消费到上文提到的 defaultValueLink 组件和 a 标签 区别Link 做了 3 件事情：有 onclick 那就执行 onclickclick 的时候阻止 a 标签默认事件、不会跳转和刷新页面再取得跳转 href（即是 to），用 history（前端路由两种方式之一，history &amp; hash）跳转，此时只是链接变了，并没有刷新页面switch 标签作用有标签，则其中的在路径相同的情况下，只匹配第一个，这个可以避免重复匹配withRouter 作用让被修饰的组件可以从属性中获取 history,location,match路由组件可以直接获取这些属性，而非路由组件就必须通过 withRouter 修饰后才能获取这些属性了React 编程模型宿主树用于展示 UI会随时间变化稳定性，宿主树相对稳定通用性，宿主树可以被拆分为外观和行为一致的 UI 模式宿主实例宿主树的节点渲染器渲染器决定如何与特定的宿主环境通信以及如何管理它的宿主实例让开发者能以一种更好的方式操控宿主实例，而不用在意低级视图 API 范例React 元素最小的构建单元一个普通的 JavaScript 对象，用来描述一个宿主实例React 元素也能形成一棵树React 元素并不是永远存在的，它们总是在重建和删除之间不断循环React 元素具有不可变性。不能改变 React 元素中的子元素或者属性，如果想要在稍后渲染一些不同的东西，需要从头创建新的 React 元素树来描述它类似电影中放映的每一帧入口告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去，例如，React DOM 的入口就是 ReactDOM.render()组件即返回 React 元素的函数一致性React 将所有的工作分成了“渲染阶段”和“提交阶段”。渲染阶段是当 React 调用你的组件然后进行协调的时段，在此阶段进行干涉是安全的，提交阶段就是 React 操作宿主树的时候，而这个阶段永远是同步的批量更新React 会在组件内所有事件触发完成后再进行批量更新，避免浪费的重复渲染上下文事实上，当 React 渲染时，维护了一个上下文栈副作用React 会推迟执行 effect 直到浏览器重新绘制屏幕有一个极少使用的 Hook 能够让你选择退出这种行为并进行一些同步的工作，请尽量避免使用它：useLayoutEffect自定义 Hooks自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。渲染器react-dom、react-dom/server、 react-native、 react-test-renderer 都是常见的渲染器不管你的目标平台是什么，react 包都是可用的，从 react 包中导出的一切，比如 React.Component、React.createElement、 React.Children 和 Hooks，都是独立于目标平台的渲染器包则暴露特定平台的 API，例如 ReactDOM.render()react 包仅仅是让你使用 React 的特性，但是它不知道这些特性是如何实现的。渲染器包(react-dom、react-native 等)提供了 React 特性的实现以及平台特定的逻辑每个渲染器都在已创建的类上设置了一个特殊的字段，这个字段叫做 updater"}]},{"id":"前端技术\\Javascript","dirname":"Javascript","filename":"","basename":"","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","children":[{"id":"前端技术\\Javascript\\Promise.md","filename":"Promise.md","basename":"Promise","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"参考https://es6.ruanyifeng.com/#docs/promise描述用来解决 es5 时期的回调地狱实例化一个 Promise 需要传入一个函数，代码在这个函数中执行，这个函数往往接收两个参数 resolve 和 reject，当作函数来执行在函数中代码执行成功了，调用 resolve 函数，可以把 Promise 的状态变为已成功，通过参数把成功的结果传递出去，能在这个 Promise 对象的 then 方法中获取，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果在函数中业务代码执行失败了，调用 reject 函数，可以把 Promise 的状态变为已失败，通过参数把失败的结果传递出去，能在这个 Promise 对象的 catch 方法中获取，catch 方法和 then 方法用法一致，也是接受一个函数作为参数无论结果如何都会走 finally 方法Promise.all：接受一个数组作为参数，都是 Promise 实例，调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是已完成，结果的状态才会是已完成，只要有一个失败，结果就是失败Promise.race：接受一个数组作为参数，都是 Promise 实例，返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回那个结果Promise.resolve()：直接返回一个成功状态的 Promise 对象，接受一个参数，这个参数可以是：成功的结果、Promise 实例、不带有参数Promise.reject()：失败，同上Promise 实现链式调用原理每个方法其实都是返回一个新的 Promise 对象手写 Promise// 在这里用Symbol定义三种状态，防止外部改变状态const Pending = Symbol(&#x27;Pending&#x27;);// 进行中const Fulfilled = Symbol(&#x27;Fulfilled&#x27;);// 已成功const Rejected = Symbol(&#x27;Rejected&#x27;);// 已失败const handleValue = (promise, x, resolve, reject) =&gt; {  // 循环引用，自己等待自己完成，会出错，用reject传递出错误原因  if (promise === x) {    return reject(new TypeError(&#x27;检测到Promise的链式循环引用&#x27;));  }  // 确保递归解析中只传递出去一次值  let once = false;  if ((x !== null &amp;&amp; typeof x === &#x27;object&#x27;) || typeof x === &#x27;function&#x27;) {    try {      // 防止重复去读取x.then      let then = x.then;      // 判断x是不是Promise      if (typeof then === &#x27;function&#x27;) {        //调用then实例方法处理Promise执行结果        then.call(          x,          (y) =&gt; {            if (once) return;            once = true;            // 防止Promise中Promise执行成功后又传递一个Promise过来，            // 要做递归解析。            handleValue(promise, y, resolve, reject);          },          (r) =&gt; {            if (once) return;            once = true;            reject(r);          }        );      } else {        // 如果x是个普通对象，直接调用resolve(x)        resolve(x);      }    } catch (err) {      if (once) return;      once = true;      reject(err);    }  } else {    // 如果x是个原始值，直接调用resolve(x)    resolve(x);  }};class Promise {  constructor(executor) {    this.status = Pending;    //存储 Promise 的状态    this.value = undefined;    //存储executor函数中业务代码执行成功的结果    this.reason = undefined;    //存储executor函数中业务代码执行失败的原因    this.onFulfilled = [];    //executor函数中业务代码执行成功回调函数的集合    this.onRejected = [];    //executor函数中业务代码执行失败回调函数的集合    const resolve = (value) =&gt; {      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。      if (this.status === Pending) {        this.status = Fulfilled;        this.value = value;        // 依次调用成功回调函数        this.onFulfilled.forEach((fn) =&gt; fn());      }    };    const reject = (value) =&gt; {      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。      if (this.status === Pending) {        this.status = Rejected;        this.reason = value;        // 依次调用失败回调函数        this.onRejected.forEach((fn) =&gt; fn());      }    };    try {      executor(resolve, reject);    } catch (error) {      reject(error);    }  }  then(onFulfilled, onRejected) {    onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : (v) =&gt; v;    onRejected =      typeof onRejected === &#x27;function&#x27;        ? onRejected        : (err) =&gt; {            throw err;          };    let promise = new Promise((resolve, reject) =&gt; {      if (this.status === Fulfilled) {        setTimeout(() =&gt; {          try {            let x = onFulfilled(this.value);            handleValue(promise, x, resolve, reject);          } catch (error) {            reject(error);          }        }, 0);      }      if (this.status === Rejected) {        if (onRejected &amp;&amp; typeof onRejected === &#x27;function&#x27;) {          setTimeout(() =&gt; {            try {              let x = onRejected(this.reason);              handleValue(promise, x, resolve, reject);            } catch (error) {              reject(error);            }          }, 0);        }      }      if (this.status === Pending) {        this.onFulfilled.push(() =&gt; {          setTimeout(() =&gt; {            try {              let x = onFulfilled(this.value);              handleValue(promise, x, resolve, reject);            } catch (error) {              reject(error);            }          }, 0);        });        if (onRejected &amp;&amp; typeof onRejected === &#x27;function&#x27;) {          this.onRejected.push(() =&gt; {            setTimeout(() =&gt; {              try {                let x = onRejected(this.reason);                handleValue(promise, x, resolve, reject);              } catch (error) {                reject(error);              }            }, 0);          });        }      }    });    return promise;  }  static resolve(param) {    if (param instanceof Promise) {      return param;    }    return new Promise((resolve, reject) =&gt; {      if (param &amp;&amp; Object.prototype.toString.call(param) === &#x27;[object Object]&#x27; &amp;&amp; typeof param.then === &#x27;function&#x27;) {        setTimeout(() =&gt; {          param.then(resolve, reject);        }, 0);      } else {        resolve(param);      }    });  }  static reject(param) {    return new Promise((resolve, reject) =&gt; {      reject(param);    });  }  static all(promises) {    //将参数promises转为一个真正的数组    promises = Array.from(promises);    return new Promise((resolve, reject) =&gt; {      const length = promises.length;      let value = [];      if (length) {        value = Array.apply(null, { length: length });        for (let i = 0; i &lt; length; i++) {          Promise.resolve(promises[i]).then(            (res) =&gt; {              value[i] = res;              if (value.length == length) {                resolve(value);              }            },            (err) =&gt; {              reject(err);              return;            }          );        }      } else {        resolve(value);      }    });  }  static race(promises) {    //将参数promises转为一个真正的数组    promises = Array.from(promises);    return new Promise((resolve, reject) =&gt; {      const length = promises.length;      if (length) {        for (let i = 0; i &lt; length; i++) {          Promise.resolve(promises[i]).then(            (res) =&gt; {              resolve(res);              return;            },            (err) =&gt; {              reject(err);              return;            }          );        }      } else {        return;      }    });  }}promise.catch 是不是微任务是的"},{"id":"前端技术\\Javascript\\代理对.md","filename":"代理对.md","basename":"代理对","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"参考：https://zh.javascript.info/string所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。这些符号的 length 是 2：alert(&#x27;𝒳&#x27;.length); // 2，大写数学符号alert(&#x27;😂&#x27;.length); // 2，部分 emoji 表情alert(&#x27;𩷶&#x27;.length); // 2，罕见的中国象形文字代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理"},{"id":"前端技术\\Javascript\\其他.md","filename":"其他.md","basename":"其他","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"Array 的一些不好记的方法全部：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Arraypush(element1, ..., elementN)：在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，会改变原数组pop()：删除数组的最后一个元素，并返回该元素，会改变原数组shift()：删除数组的第一个元素，并返回该元素，会改变原数组unshift(element1, ..., elementN)：在数组的第一个位置添加元素，并返回添加新元素后的数组长度，会改变原数组join([separator])：以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔，[1, 2, 3] =&gt; '1,2,3'slice([begin[, end]])：用于提取目标数组的一部分，返回一个新数组，原数组不变splice(start[, deleteCount[, item1[, item2[, ...]]]])：用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。会改变原数组String 的一些不好记的方法全部：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Stringsubstr(start[, length])：要被废弃，跟 slice 和 substring 方法的作用相同split([separator[, limit]])：按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组 '1,2,3' =&gt; [1, 2, 3]substring(indexStart[, indexEnd])：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集slice(beginIndex[, endIndex])：提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串数组的遍历迭代方法for in以任意顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性。for ofES6 新增，用来替代 for in 和 forEach，可以遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构。forEach遍历数组中的每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行。map返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。flat将嵌套的数组“拉平”，变成一维的数组，返回一个新数组，对原数据没有影响，默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat()方法的参数写成一个整数flatMap对原数组的每个成员执行一个函数（相当于 map），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组，只能展开一层数组filter返回通过过滤的元素，不改变原来的数组。some用于检测数组中的某个元素是否满足指定条件,返回 boolean 值，不改变原数组。every用于检测数组中的所有元素是否都符合指定条件，返回 boolean 值，不改变原数组。reduce接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduceRight和 reduce() 功能是一样的，它是从数组的末尾处向前开始计算。find 返回通过测试（函数内判断）的数组的第一个元素的值。forEach、for in、for of 三者区别：forEach 更多的用来遍历数组for in 一般常用来遍历对象或 jsonfor of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()for in 循环出的是 key，for of 循环出的是 valuees6 新特性箭头函数Promise拓展运算符和解构赋值对象和数组解构let const模板字符串函数的参数默认值classfor…of 和 for…in模块尾调用优化 TCOvar let constconst 用于声明常量，const 声明的一般类型的变量，不能修改const 声明的对象，属性可以被修改用 var 重复声明不会报错，但 let 和 const 会var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错。垃圾回收现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数标记清除（主流）垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记因为只要上下文中的代码在运行，就有可能用到它们从根部出发将能触及到的对象的标记清除那些还存在标记的变量被视为准备删除的变量销毁那些带标记的值引用计数如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收。跟踪记录每个值被引用的次数当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来缺点：循环引用会造成对象无法被回收如何避免垃圾回收对象尽量复用数组优化： 将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。引起内存泄漏的操作全局变量闭包dom 清除，事件绑定未清除未清除的计时器setTimeout 的第一个参数使用字符串而非函数引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环console.log 打印了太大的变量React 组件卸载后，存在异步回调中调用 setState手动释放内存fn = null【null：空指针对象】深拷贝、浅拷贝浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 或 展开运算符深拷贝：JavaScript 包含基本类型（如字符串、数字、布尔）和引用类型（如数组、对象）基本数据类型按值访问、引用类型的值按照引用访问直接复制引用类型的值，实际上是一个内存地址的指针，修改新的变量，原变量也会被修改手写深拷贝：function deepCopy(obj) {  // 1、判断是否是简单数据类型，  if (typeof obj == &#x27;object&#x27;) {    // 2、复杂数据类型    var result = obj.constructor == Array ? [] : {};    for (let i in obj) {      result[i] = typeof obj[i] == &#x27;object&#x27; ? deepCopy(obj[i]) : obj[i];    }  } else {    // 简单数据类型 直接赋值    var result = obj;  }  return result;}async/awaitasync 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 awaitawait 用来等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误实现原理Generator 函数的语法糖将 Generator 函数和自动执行器，包装在一个函数里async function fn(args) {  // ...}// 等同于function fn(args) {  return spawn(function* () {    // ...  });}spawn 函数就是自动执行器，spawn 函数的实现：function spawn(genF) {  return new Promise(function (resolve, reject) {    const gen = genF();    function step(nextF) {      let next;      try {        next = nextF();      } catch (e) {        return reject(e);      }      if (next.done) {        return resolve(next.value);      }      Promise.resolve(next.value).then(        function (v) {          step(function () {            return gen.next(v);          });        },        function (e) {          step(function () {            return gen.throw(e);          });        }      );    }    step(function () {      return gen.next(undefined);    });  });}apply、call、bind都是用来改变函数 this 的指向区别：apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行手写// callFunction.prototype.myCall = function (context, ...args) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  // 判断 context 是否传入，如果没有传就设置为 window  context = context || window;  // 使用 Symbol 来保证属性唯一  // 保证不会重写用户自己原来定义在 context 中的同名属性  const fnSymbol = Symbol();  // 将被调用的方法设置为 context 的属性  // this 即为我们要调用的方法  context[fnSymbol] = this;  // 将执行结果返回  try {    return context[fnSymbol](...args);  } finally {    // 最后删除手动增加的属性方法    delete context[fnSymbol];  }};var foo = {  value: 1,};function bar() {  console.log(this.value);}bar.call(foo); // 1bar.myCall(foo); // 1// apply// 与 call 相比仅获取参数方式不同// bindFunction.prototype.myBind = function (context, ...args) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  const fn = this;  return function Fn() {    return fn.apply(      this instanceof Fn ? this : context,      // 当前的这个 arguments 是指 Fn 的参数      args.concat(...arguments)    );  };};尾调用和尾递归指某个函数的最后一步是调用另一个函数递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出错误但对于尾递归来说，由于只存在一个调用记录，所以不会发生栈溢出function factorial(num) {  if (num === 1) return 1;  return num * factorial(num - 1);}console.log(factorial(5));console.log(factorial(10));作用域含义：用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找作用域类型：全局作用域和函数作用域用域链当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问词法作用域和动态作用域JavaScript 采用词法作用域，也就是静态作用域函数的作用域在函数定义的时候就决定了而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定var value = 1;function foo() {  console.log(value);}function bar() {  var value = 2;  foo();}bar();// 1执行上下文当函数执行时，会创建一个称为执行期上下文的内部对象（即 AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁参数传递参数如果是基本类型是按值传递，如果是引用类型按共享传递但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题按值传递把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样共享传递在传递对象的时候，传递对象的引用的副本假设 arg 是一个对象参数，修改 arg.value，可以通过引用找到原值，但是直接修改 arg，并不会修改原值arguments是一个类数组对象，存储传入函数的全部参数。（类数组对象：属性是 0 开始的下标，并且有 length 属性，但没有数组独有的方法）callee 属性：当前函数的引用妙用：递归、参数累加为什么 ES6 不推荐使用 arguments.callee()访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包。当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 calleedelete 机制使用 delete 操作符并不会直接释放内存，与 V8 引擎有关最有效的方式，应该是将不需要的属性设置为 undefined在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快0.1 + 0.2 为什么不等于 0.3二进制模拟十进制进行计算时的精度问题进制转换：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失对阶运算：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度如何设置一个对象所有属性不能修改Object.preventExtensions()Object.seal() 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，当前属性的值只要原来是可写的就可以改变Object.freeze() 使用 Object.freeze()冻结的对象中的现有属性值是不可变的。用 Object.seal()密封的对象可以改变其现有属性值"},{"id":"前端技术\\Javascript\\原型链和继承.md","filename":"原型链和继承.md","basename":"原型链和继承","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"参考https://github.com/mqyqingfeng/blog/issues/2原型链描述原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性或方法，其实就是 prototype 对象由相互关联的原型组成的链状结构就是原型链原型对象上的所有属性和方法，都能被对应构造函数创建的实例共享，这是 JavaScript 继承机制的基本设计JavaScript 对象通过 prototype 指向父类对象，直到指向 Object 对象，Object 原型指向 null 为止，这样就形成了一个原型指向的链条访问实例的某个属性或方法，会首先在对象内寻找，找不到，才在对象的原型里去找，一直找到底instanceof、isPrototypeOf：判断是否处于原型链Object.hasOwnProperty()：检查对象自身中是否含有该属性for in 可以搜索原型属性函数对象的 prototype --&gt; 实例原型实例（普通对象）的 __proto__ --&gt; 实例原型原型的 constructor --&gt; 关联的构造函数实例原型的原型 --&gt; ObjectObject 的原型 --&gt; null，Object.prototype.__proto__ === null此时原型链停止查找null 表示“没有对象”，即该处不应该有值。所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思原型对象 和 构造函数在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象当函数经过 new 调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个 __proto__ 属性，指向构造函数的原型对象声明方法为什么要用 prototype为了在类的各个实例间共享通过该构造函数生成的实例所拥有的方法都是指向一个函数的索引，这样可以节省内存不使用 prototype 定义的方法相当于类的静态方法，可以直接使用，不需要 new使用 prototype 定义的方法相当于类的实例方法，必须 new 后才能使用prototype 和 proto 和 constructor 的关系prototype 用于访问函数的原型对象。它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，任何函数在创建的时候，其实会默认同时创建该函数的 prototype 对象__proto__ 用于访问对象实例的原型对象（或者使用 Object.getPrototypeOf()）__proto__ 是对象独有的__proto__ 作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的 __proto__ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的 __proto__ 属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找，直到原型链顶端 null 空对象constructor 属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数typeof 和 instanceof 区别typeof：判断一个变量的类型instanceof：判断一个变量是否是某个对象的实例instanceof 原理：能在实例的 原型对象链 中找到该构造函数的 prototype 属性所指向的 原型对象，就返回 truenew 干了什么new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。创建一个空对象将构造函数的作用域赋给新对象，根据原型链，设置空对象的 __proto__ 为构造函数的 prototype构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象手写 new：function myNew(context, ...args) {  const obj = new Object();  obj.__proto__ = context.prototype;  const res = context.apply(obj, args);  return typeof res === &#x27;object&#x27; ? res : obj;}继承许多面向对象语言都支持两种继承方式: 接口继承 和 实现继承JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承JavaScript 也没有在语言层面提供对抽象类和接口的支持接口继承只继承方法签名，而实现继承则继承实际的方法在 JavaScript 中无法实现接口继承，只支持实现继承，而且其实现继承主要是依靠原型链来实现的以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链原型链继承直接通过原型继承属性和方法Son.prototype = new Father();缺点：原型中包含引用值的时候，会在所有实例间共享，修改子类引用类型属性会影响到父类子类型在实例化时不能给父类型的构造函数传参盗用构造函数为了解决原型包含引用值导致的继承问题（含引用类型值的原型属性会被所有实例共享）在子类型构造函数的内部调用父类型构造函数优点是可以在子类构造函数中向父类构造函数传参function Father() {  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];}function Son() {  Father.call(this);  // 继承了Father，且向父类型传递参数}缺点：必须在构造函数中定义方法，因此函数不能重用子类也不能访问父类原型上定义的方法组合继承原型链继承和盗用构造函数继承的结合使用原型链实现对原型属性和方法的继承通过盗用构造函数来实现对实例属性的继承既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性function Father(name) {  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];}Father.prototype.sayName = function () {  alert(this.name);};function Son(name, age) {  // 继承属性  Father.call(this, name);  this.age = age;}// 继承方法Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function () {  alert(this.age);};原型式继承即相当于 ES6 的 Object.create()方法适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合创建一个临时构造函数将传入的对象赋值给这个构造函数的原型然后返回这个临时类型的一个实例function object(o) {  function F() {}  F.prototype = o;  return new F();}寄生式继承类似工厂模式创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象适合主要关注对象，而不在乎类型和构造函数的场景通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似var book = { name: &#x27;js book&#x27;, likeBook: [&#x27;html book&#x27;, &#x27;css book&#x27;] };function createBook(obj) {  // 通过原型方式创建新的对象  var o = new inheritObject(obj);  // 拓展新对象  o.getName = function (name) {    console.log(name);  };  // 返回拓展后的新对象  return o;}寄生组合继承组合继承的问题：会调用两次父类型构造函数，创建子类原型时、在子类构造函数内部通过借用构造函数来继承属性通过原型链的混成形式来继承方法不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已function Father(foo) {  this.foo = foo;}Father.prototype.printFoo = function () {  console.log(this.foo);};function Son(bar) {  this.bar = bar;  Father.call(this);}Son.prototype = Object.create(Super.prototype);Son.prototype.constructor = Son;ES6 的 extendsclass Father {  constructor(foo) {    this.foo = foo;  }  printFoo() {    console.log(this.foo);  }}class Son extends Father {  constructor(foo, bar) {    super(foo);    this.bar = bar;  }}"},{"id":"前端技术\\Javascript\\数据类型.md","filename":"数据类型.md","basename":"数据类型","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"js 数据类型基本类型：number、string、boolean、undefined、null、Symbol、BigInt引用类型：Object、Array、Function、内置对象（Date、Math 等等）栈内存：是一种特殊的线性表，它具有后进先出的特性，存放基本类型堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象)基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体数据类型的判断typeof：能判断基本类型、函数。不能判断 null、对象、数组，因为都返回 objectinstanceof：能判断对象类型，不能判断基本数据类型，机制是判断在对象原型链中能否找到该类型的原型Object.prototype.toString.call()：所有类型都能判断，还有 Error 对象，Date 对象等如何判断是否数组Array.isArray(arr)arr.__proto__ === Array.prototypearr instanceof ArrayObject.prototype.toString.call(arr)null 和 undefined 区别null 表示没有对象，即该处不应该有值undefined 表示缺少值，即此处应该有值，但没有定义typeof null 为 objecttypeof undefined 为 undefinednull 和 undefined 转换成 number 数据类型时，null 转成 0 undefined 转成 NaN为什么会出现精度丢失这跟浮点数在计算机内部（用二进制存储）的表示方法有关JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出解决：使用 Number.EPSILON 误差范围Number.EPSILON 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值function isEqual(a, b) {  return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.1 + 0.2, 0.3)); // trueBigInthttps://zh.javascript.info/bigint提供了对任意长度整数的支持BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数创建 bigint 的方式有两种：在一个整数字面量后面加 n 或者调用 BigInt 函数，该函数从字符串、数字等中生成 bigintconst bigint = 1234567890123456789012345678901234567890n;const sameBigint = BigInt(&#x27;1234567890123456789012345678901234567890&#x27;);const bigintFromNumber = BigInt(10); // 与 10n 相同BigInt 不支持一元加法"},{"id":"前端技术\\Javascript\\模块.md","filename":"模块.md","basename":"模块","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"模块化机制模块化的实现：常用 IIFE 模式实现模块化：匿名函数自调用，将数据和行为封装到一个函数内部，外部依赖通过参数传入常见的模块规范：ES6 模块（esm）、CommonJS、CMD、AMD什么是 Tree Shaking消除无用的 js 代码的算法，集成在 webpack 和 rollup 等打包工具中CommonJS通用环境，比如 nodejs，不局限于浏览器每个模块提供一个 module 变量一个文件一个模块可以动态引入，所以不支持树摇特点：语法相对简单，浏览器不直接支持AMD明确基于浏览器基本退出了历史舞台RequireJS 是 AMD 的一个实现特点：异步加载、同一个文件定义一个模块ESMesm 是 javascript 的标准功能，是语言规范，是官方明确的发展方向，cjs 也只是 esm 出来之前的临时解决方案而已相比 cjs 的好处是可以使用 tree shaking，支持静态分析模块脚本自动采用严格模式模块顶层的 this 关键字返回 undefinedesm 是编译时加载，也就是只有所有 import 的模块都加载完成，才会开始执行，这有利于引擎的静态分析，加载的过程会先于代码的执行，却也导致 import 导入语句不能在函数或者 if 语句中执行。es2020 提案引入 import() 函数，用来动态加载模块，并且可以用在函数和 if 语句中模块缓存：同一个模块如果加载多次，只会执行一次export 导出的是值引用，当模块内部的值被修改时，esm 可以获取到被修改后的值，cjs 获取不到CommonJS，ESM 区别都属于不同的模块规范，require 属于 CommonJS 规范，import 属于 ES modulerequire 支持动态导入，import 不支持它们都是一种模块规范，例如 Node 使用的就是 CommonJS 规范。ES module 则是语言标准上的模块规范 区别：CommonJS 模块使用 require() 和 module.exports，ES6 模块使用 import 和 exportCommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用CommonJS 模块是运行时加载，ES6 模块是编译时输出接口，是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成，而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块UMD通用模块定义规范（Universal Module Definition）可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。未来同一个 JavaScript 包运行在浏览器端、服务区端甚至是 APP 端都只需要遵守同一个写法就行了是前端实现跨平台技术需求发展下的产物它没有自己专有的规范，是集结了 CommonJs、CMD、AMD 的规范于一身，一个简单实现的例子：((root, factory) =&gt; {  if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {    // AMD    define([&#x27;jquery&#x27;], factory);  } else if (typeof exports === &#x27;object&#x27;) {    // CommonJS    var $ = requie(&#x27;jquery&#x27;);    module.exports = factory($);  } else {    // 没有模块环境，直接挂载在全局对象上    root.testModule = factory(root.jQuery);  }})(this, ($) =&gt; {  return {    name: &#x27;我是一个umd模块&#x27;,  };});/*  定义一个 IIFE，  在定义模块的时候检测当前使用环境和模块的定义方式，  将各种模块化定义方式转化为同样一种写法，\t先判断当前环境如果支持 AMD，则使用 require.js 提供的 define 函数定义模块，\t再判断是否 cjs，如果是则使用 cjs 相应的模块定义方法进行模块定义，  如果还需要兼容其他类型的模块系统也是类似思路去兼容，  最后如果没有模块环境，直接挂载在全局对象上，这个传进来的全局对象 this，其值可能是 window 或者 global，视运行环境而定*/"},{"id":"前端技术\\Javascript\\正则表达式.md","filename":"正则表达式.md","basename":"正则表达式","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"xmind源文件"},{"id":"前端技术\\Javascript\\闭包.md","filename":"闭包.md","basename":"闭包","path":"D:\\repos\\doc-builder\\markdown\\前端技术\\Javascript","relative_path":"前端技术\\Javascript","output_path":"D:\\repos\\doc-builder\\docs\\前端技术\\Javascript","content":"闭包函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量能够访问已经被销毁的执行期上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象应用：设计私有的方法和变量。优点：可以避免全局变量的污染缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露。闭包实现累加function A() {  let start = 0;  function B() {    return ++start;  }  return B;}const inc = A();console.log(inc());console.log(inc());console.log(inc());如何优化闭包通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）function outerFun(outerArg) {  return function () {    console.log(&#x27;这里是内部匿名函数&#x27;);    console.log(&#x27;可以访问包含函数的变量&#x27;, outerArg);  };}var create = outerFun(&#x27;hi&#x27;);// 创建一个函数，是 outerFun 中返回的匿名函数create();// 调用函数，是调用匿名函数create = null;// 释放对匿名函数的引用如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题。利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁。"}]},{"id":"前端技术\\Babel.md","filename":"Babel.md","basename":"Babel","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"概念一个 JavaScript 翻译器将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）基本工作原理第 1 步 解析（Parse）通过解析器 babylon 将代码解析成抽象语法树，包括词法分析和语法分析，词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树第 2 步 转换（TransForm）通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树第 3 步 生成（Generate）通过 babel-generator 将 AST 树生成 es5 代码，同时也能创建 Source Map 映射配置主要分为 presets 和 plugins.babelrc._ 和 babel.config._ 区别.babelrc._ 仅适用于项目的某个部分babel.config._ 会影响整个项目中的代码，包含 node_modules 中的代码推荐使用 babel.config._，Babel 自身使用的就是这种格式presets逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，可以是数组、对象、字符串{  &quot;presets&quot;: [    &quot;presetA&quot;, // bare string    [&quot;presetA&quot;], // wrapped in array    [&quot;presetA&quot;, {}] // 2nd argument is an empty options object  ]}useBuiltIns{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      {        &quot;useBuiltIns&quot;: &quot;usage&quot;,        &quot;debug&quot;: true,        &quot;corejs&quot;: 3 // 建议使用 3，core-js@2 分支中已经不会再添加新特性，新特性都会添加到 core-js@3      }    ]  ]}babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presets，babel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码的最上方手动引入 @babel/polyfill 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，并且不需要手动引入 @babel/polyfill存在的问题polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量，babel 会向翻译后的每一个文件原地定义许多帮助函数，用于转义语法，比如 __spreadArray、__generator,plugins本质是一个 JS 程序, 指示 Babel 如何对代码进行转换排列顺序很重要plugins 在 presets 之前运行plugins 顺序从前往后排列，与 presets 相反核心与其周边@babel/corebabel 使用了微内核的架构风格，也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的，@babel/core 就是这个内核，包含核心功能作用：加载和处理配置(config)加载插件调用 Parser 进行语法解析，生成 AST调用 Traverser 遍历 AST，并使用访问者模式应用'插件'对 AST 进行转换生成代码，包括 SourceMap 转换和源代码生成@babel/cli命令行工具@babel/plugin-transform-runtime、@babel/runtime这个插件就是为了解决 useBuiltIns polyfill 污染全局的问题和每一个文件都有辅助函数问题，将 babel 转译时添加到文件中的内联辅助函数统一隔离到 babel-runtime 提供的 helper 模块中编译时，直接从 helper 模块加载，不在每个文件中重复的定义辅助函数，从而减少包的尺寸其中 @babel/plugin-transform-runtime 的作用是转译代码，转译后的代码中可能会引入 @babel/runtime-corejs3 里面的模块。前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行@babel/plugin-transform-runtime 通常仅在开发时使用，但是运行时最终代码需要依赖 @babel/runtime，所以 @babel/runtime 必须要作为生产依赖被安装typescript 的 importHelpers 配置和 tslib 也是类似的原理安装：$ yarn add @babel/plugin-transform-runtime -D$ yarn add @babel/runtime-corejs3修改配置如下：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;      // 移除，否则和下面重复了      // {      //   &quot;useBuiltIns&quot;: &quot;usage&quot;,      //   &quot;debug&quot;: true      // }    ]  ],  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      {        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本      }    ]  ]}引入了这个插件后：api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个@babel/parser将源代码解析为 AST已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范@babel/traverse实现了访问者模式，对 AST 进行遍历，转换插件会通过它获取感兴趣的 AST 节点，对节点继续操作@babel/generator将 AST 转换为源代码，支持 SourceMap@babel/preset-env语法转换插件的集合可以根据目标浏览器运行环境配置（browserslist、targets），将 ES2015+ 的语法转换为 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）core.js新 api 集合@babel/polyfill@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs引入 @bable/polyfill 就相当于在代码中引入下面两个库import &#x27;core-js/stable&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)regenerator-runtime生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物"},{"id":"前端技术\\CSS.md","filename":"CSS.md","basename":"CSS","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"CSS层叠上下文z-index 属性值并不是在任何元素上都有效果。它仅在定位元素上有效果。（定义了 position 属性，且属性值为非 static 值的元素）产生层叠上下文：设置 position 为非 static 值css3 新特性选择器 nth-child边框圆角渐变色颜色透明度多列布局弹性布局过渡、动画flex媒体查询一行的时候居中，多行的时候左对齐利用行内元素的特点，父元素 text-align: center，子元素设为行内元素，设置 text-align: left怎么清除浮动clear:both;br 标签清浮动，br 标签存在一个属性：clear。这个属性能够清除浮动，在 br 标签中设置属性 clear，并赋值 all。即能清除掉浮动。CSS 选择器优先级!important内联样式ID 选择器类选择器/属性选择器/伪类选择器元素选择器/关系选择器/伪元素选择器通配符选择器BFCBFC 全称为块级格式化上下文BFC 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局一个环境中的元素不会影响到其它环境中的布局比如浮动元素会形成 BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的可以说 BFC 就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里的布局与这个容器外毫不相干触发 BFC 的条件根元素或其它包含它的元素浮动元素 (元素的 float 不是 none)绝对定位元素 (元素具有 position 为 absolute 或 fixed)内联块 (元素具有 display: inline-block)表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)具有 overflow 且值不是 visible 的块元素弹性盒（flex 或 inline-flex）display: flow-rootcolumn-span: all行级块级区别块级可设置宽高，单独成行行内元素设置宽高无效，宽高由内容撑起盒模型标准盒模型：高宽仅为内容怪异盒模型：高宽包括内容+边框+内边距水平居中内行元素使用 text-align: centermargin: auto元素为绝对定位使用 left:0; right:0; margin: auto使用 flex垂直居中单行文字使用 lineheight使用 flex绝对定位元素：bottom:0; top:0; margin:auto绝对定位元素：top:50%; margin-top:-(元素高度一半)各个单位区别 rem、em、vh、px画一条 0.5px 的直线height: 1px;transform: scale(0.5);link 与 @import 的区别link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载@import 需要 IE5 以上才能使用link 可以使用 js 动态引入，@import 不行渐进增强和优雅降级渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。margin 重叠问题兄弟级的垂直块之间，margin 这个属性上下边距，会发生重叠的情况，float 浮动或 display:inline-block父子级的块之间，子级的上下 margin 会与父级上下 margin 重叠，父级加 overflow:hidden 或加 padding 或加 border，子级加 position:absolute相邻盒子高度自动同步flex不使用 flex 布局，使用 table 布局让左右两侧 div 元素高度一致：https://codepen.io/qxtang/pen/RwxdXqe"},{"id":"前端技术\\Flex布局.md","filename":"Flex布局.md","basename":"Flex布局","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"意义相比以前 display + position + float 的方式布局，Flex 可以更简便地实现多种页面布局flex: 1 的意思？是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个是可选属性定义项目的放大比例容器属性flex-direction决定主轴方向flex-wrap让 Flex 项目换行排列默认子元素都排在一条线上nowrap(默认)：所有子元素单行排列wrap：所有子元素多行排列，按从上到下的顺序wrap-reverse：所有子元素多行排列，按从下到上的顺序flex-flowflex-direction 属性和 flex-wrap 属性的简写形式.box {  flex-flow: &lt; &#x27;flex-direction&#x27; &gt; || &lt; &#x27;flex-wrap&#x27; &gt;;}justify-content定义了项目在主轴上的对齐方式及额外空间的分配方式.box {  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;}align-items定义项目在交叉轴上的对齐方式.box {  align-items: stretch | flex-start | flex-end | center | baseline;}align-content定义了在交叉轴方向的对齐方式及额外空间分配，类似于主轴上 justify-content 的作用.box {  align-content: stretch | flex-start | flex-end | center | space-between | space-around;}align-content 与 align-items 的区别？align-content 只适用多行的 flex 容器，也就是 flex 容器中的子项不止一行时该属性才有效果当 flex 容器在交叉轴上有多余的空间时，将子项作为一个整体（属性值为：flex-start、flex-end、center 时）进行对齐效果如下：子元素属性order控制元素在容器中的先后顺序从小到大顺序排列，可以为负值，默认为 0flex-grow正整数，定义项目的放大比例flex-shrink定义了元素的缩小比例，默认为 1即如果空间不足，该元素将被挤压0 表示不缩小，负值无效flex-basis定义元素在分配额外空间之前的缺省尺寸属性值可以是长度（20%，10rem 等）或者关键字 auto，默认值 autoflexflex-grow, flex-shrink 和 flex-basis 的简写，默认值：0 1 auto，后两个可选align-self定义项目的对齐方式，可覆盖 align-items，默认 auto"},{"id":"前端技术\\NodeJS.md","filename":"NodeJS.md","basename":"NodeJS","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"nodejs 特点它是一个 Javascript 运行环境依赖于 Chrome V8 引擎进行代码解释事件驱动非阻塞 I/O单进程，单线程nodejs 解决的问题并发连接异步机制、事件驱动整个过程没有阻塞新用户的连接，也不需要维护已有用户的连接。基于这样的机制，理论上陆续有用户请求连接，NodeJS 都可以进行响应，因此 NodeJS 能支持比 Java、PHP 程序更高的并发量.虽然维护事件队列也需要成本I/O 阻塞Java、PHP 也有办法实现并行请求（子线程），但 NodeJS 通过回调函数（Callback）和异步机制会做得很自然。nodejs 的优缺点优点：高并发（最重要的优点）适合 I/O 密集型应用缺点：不适合 CPU 密集型应用，由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起；只支持单核 CPU，不能充分利用 CPU可靠性低，一旦代码某个环节崩溃，整个系统都崩溃开源组件库质量参差不齐，更新快，向下不兼容解决方案：Nginx 反向代理，负载均衡，开多个进程，绑定多个端口开多个进程监听同一个端口，使用 cluster 模块；使用比如 pm2 之类的工具应用场景RESTful API统一 Web 应用的 UI 层大量 Ajax 请求的应用nodejs 异常处理try catch，缺点明显：无法处理异步代码块内出现的异常，比如 setTimeout使用 event 原生模块，监听 error 事件原生模块的 callback 函数一般都会抛出错误（第一个参数）node 模块模块规范Node 模块系统借鉴 CommonJS 来实现CommonJS 对模块的定义主要分为：模块引用、模块定义和模块标识 3 个部分模块引用存在 require() 方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中模块定义上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式模块标识就是传递给 require() 方法的参数符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径可以没有文件名后缀.js模块实现在 Node 中引入模块，需要经历 3 个步骤：路径分析、文件定位、编译执行Node 模块分为两类：Node 提供的模块（核心模块）、用户编写的模块（文件模块）两种类型区别核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块已被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢缓存优先特性Node 对引入过的模块都会进行缓存，以减少二次引入时的开销，Node 缓存的是编译和执行之后的对象路径分析标识符的分类：核心模块、.或..开始的相对路径、以/开始的绝对路径、非路径形式核心模块：核心模块的优先级仅次于缓存加载；它在 Node 的源代码编译过程中已经编译为二进制代码，加载过程最快路径形式：1、转为真实路径；2、将编译执行后的结果存放到缓存中；自定义模块（非路径形式，可能是一个包的形式）：这类模块的查找是最费时的，也是所有方式中最慢的一种文件定位扩展名分析：允许在标识符中不包含文件扩展名，会按.js、.json、.node 的次序补足扩展名，依次尝试，调用了 fs 模块同步阻塞式地判断文件是否存在，所以如果是 .node 和 .json 文件，在传递给 require() 的标识符中带上扩展名，会加快一点速度可能没有查找到对应文件，如果得到一个目录，此时将目录当做一个包来处理，查找 package.json 的 main 属性，同样进行拓展名分析如果 package.json 和 main 字段没有找到，则寻找文件夹下的 index 文件，同样进行拓展名分析最后都没找到则抛出查找失败的异常编译执行.js 文件：通过 fs 模块同步读取文件后编译执行.node 文件：这是用 C/C++ 编写的扩展文件，通过 dlopen() 方法加载最后编译生成的文件.json 文件：通过 fs 模块同步读取文件后，用 JSON.parse() 解析返回结果其余扩展名：它们都被当做.js 文件载入每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能模块内部全局变量的由来require、exports、module、__filename、__dirname等变量的由来：在编译的过程中，Node 对获取的 JavaScript 文件内容进行了头尾包装。在头部添加了 (function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了 \\n})这样每个模块文件之间都进行了作用域隔离包结构package.json：包描述文件bin：用于存放可执行二进制文件的目录lib：用于存放 JavaScript 代码的目录doc：用于存放文档的目录test：用于存放单元测试用例的代码nodejs 事件循环node 事件循环与浏览器的区别https://juejin.cn/post/6844903761949753352cluster 原理pipe 原理洋葱圈模型每次当有一个请求进入的时候，每个中间件都会被执行两次每个中间件都接收了一个 next 参数，在 next 函数运行之前的中间件代码会在一开始就执行，next 函数之后的代码会在内部的中间件全部运行结束之后才执行，就像一根筷子穿过一个洋葱，同一层皮会被筷子穿过两次实现思路this.middleware 是中间件集合的数组koa-compose 模块的 compose 方法用来构建执行顺序// middleware 用来保存中间件app.use = (fn) =&gt; {  this.middleware.push(fn);  return this;};// compose 组合函数来规定执行次序function compose(middleware) {  // context：上下文，next：传入的接下来要运行的函数  return function (context, next) {    function dispatch(i) {      index = i;      // 中间件      let fn = middleware[i];      if (!fn) return Promise.resolve();      try {        // 我们这边假设和上文中的例子一样，有A、B、C三个中间件        // 通过dispatch(0)发起了第一个中间件A的执行        // A中间件执行之后，next作为dispatch(1)会被执行        // 从而发起了下一个中间件B的执行，然后是中间件C被执行        // 所有的中间件都执行了一遍后，执行Promise.resolve()        // 最里面的中间件C的await next()运行结束，会继续执行console.log(&quot;C2&quot;)        // 整个中间件C的运行结束又触发了Promise.resolve        // 中间件B开始执行console.log(&quot;B2&quot;)        // 同理，中间件A执行console.log(&quot;A2&quot;)        return Promise.resolve(          fn(context, () =&gt; {            return dispatch(i + 1);          })        );      } catch (err) {        return Promise.reject(err);      }    }    return dispatch(0);  };}"},{"id":"前端技术\\npm.md","filename":"npm.md","basename":"npm","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"参考https://www.ruanyifeng.com/blog/2016/10/npm_scripts.htmlnpm 的使用可以通过环境变量读取 package.json 中的属性：process.env.npm_package_name获取当前正在运行的 npm script 脚本名称：process.env.npm_lifecycle_event可通过添加 pre- 和 post- 前缀声明钩子脚本使用 link 调试本地包npm run 新建的 Shell 环境，会将当前目录的 node_modules/.bin 加入 PATH 环境变量，执行结束后，再将 PATH 环境变量恢复，这意味着，当前目录的 node_modules/.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径或者 npxscript 中可通过 $npm_config_tag 获取 shell 中的配置值；如果 env 环境变量中存在以 npm_config_* 为前缀的环境变量，则也会被识别为 npm 的配置属性；以及各个级别的 .npmrc 配置文件npm run serve --params  // 参数params将转化成process.env.npm_config_params = truenpm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123npm version patch升级小版本，还会默认执行 git add-&gt;git commit-&gt;git tag 操作，也可以通过配置禁止这一默认行为查看所有可用命令：npm runnpm cinpm ci 只根据 package-lock.json 来安装包，而 npm install 在安装的过程中会结合 package.json 和 package-lock.json 来计算依赖包版本的差异性问题。所以相比较 npm install，npm ci 既能提升包的安装速度，又能避免在生产化境中出现包版本不一致的问题如果项目中已经存在 node_modules，npm ci 将会先删除它，然后再安装如果检测到 package.json 和 package-lock.json 中的依赖项不匹配的话，npm ci 将退出并报错，而不是更新两个文件中的版本号要求项目中必须具有 package-lock.json 或 npm-shrinkwrap.json，否则执行 npm ci 将会报错npm ci 只能一次安装整个项目的依赖包，而不能为项目安装单个依赖包npx直接运行 node_modules/.bin 目录下的可执行文件npx 想要解决的主要问题，就是调用项目内部安装的模块，可以避免全局安装模块npx 的原理很简单，就是运行的时候，会到 node_modules/.bin 路径和环境变量 PATH 里面，检查命令是否存在。由于 npx 会检查环境变量 PATH，所以系统命令也可以调用npm 检查配置的优先级项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件 &gt; 全局级的 .npmrc &gt; npm 内置的 .npmrc 文件package-lock.json、yarn.lock 的作用锁定安装时的包的版本号，并且需要上传到 git，以保证其他人在 npm install 时大家的依赖能保证一致package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次 npm install 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。npm install 流程检查项目中是否有 package-lock.json 文件如果有， 检查 package-lock.json 和 package.json 声明的依赖是否一致：一致， 直接使用 package-lock.json 中的信息，从网络或者缓存中加载依赖不一致， 根据上述流程中的不同版本进行处理如果没有， 那么会根据 package.json 递归构建依赖树，然后就会根据构建好的依赖去下载完整的依赖资源，在下载的时候，会检查有没有相关的资源缓存:存在， 直接解压到 node_modules 文件中不存在， 从 npm 远端仓库下载包，校验包的完整性，同时添加到缓存中，解压到 node_modules 中最后， 生成 package-lock.json 文件在我们实际的项目开发中，使用 npm 作为团队的最佳实践: 同一个项目团队，应该保持 npm 版本的一致性。如果希望一个模块不管是否安装过，npm 都要强制重新安装，可以使用 -f 或–force 参数npm 的缺点包之间相互依赖，导致嵌套地狱，会形成一棵巨大的依赖树依赖层级过深，有问题不利于排查和调试安装结果占据大量空间资源，安装时间长yarn 解决的问题采用模块扁平化的安装模式: 将不同版本的依赖包，按照一定的策略，归结为单个版本；以避免创建多个版本造成工程的冗余（目前版本的 npm 也有相同的优化）网络性能更好: yarn 采用了请求排队的理念，类似于并发池连接，能够更好的利用网络资源；同时也引入了一种安装失败的重试机制采用缓存机制，实现了离线模式 （目前的 npm 也有类似的实现）依赖包版本号采用了 semver 规范作为依赖版本管理方案一般格式：主版本号.次版本号.修订号（x.y.z）package.json参考：https://docs.npmjs.com/cli/v8/configuring-npm/package-jsonbin：表示的是一个可执行文件到指定文件源的映射&quot;bin&quot;: {  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;}file：需要上传 npm 的文件，一般设置只上传编译产物，加快下载包的速度main：指定加载的入口文件browser：定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件module：定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件man：指定帮助文档typings：指定 TypeScript 的入口文件dependenciesdependencies最终上线或者发布 npm 包时所需要，例如 vue 框架、UI 组件库发布 npm 包的时候，包中的 dependencies 依赖项在安装该包的时候会被一起下载，devDependencies 依赖项则不会devDependencies开发和测试时需要，例如打包工具、css 预处理器、测试框架等peerDependencies如果你安装我，那么你最好也要按照我的要求安装 A、B 和 C可以用来防止多次引入相同的库optionalDependencies这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程如果一个依赖同时出现在 dependencies 和 optionalDependencies 中，那么 optionalDependencies 会获得更高的优先级在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用版本号第一部分为主版本号，变化了表示有了一个不兼容上个版本的大更改第二部分为次版本号，变化了表示增加了新功能，并且可以向后兼容第三部分为修订版本号，变化了表示有 bug 修复，并且可以向后兼容第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为 base、alpha、beta、RC、release希腊版本号Base此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是 页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。Alpha软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者 内部交流，一般而言，该版本软件的 Bug 较多，需要继续修改，是测试版本。测试 人员提交 Bug 经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可 将软件版本标注为 alpha 版。Beta该版本相对于 Alpha 版已经有了很大的进步，消除了严重错误，但还需要经过多次 测试来进一步消除，此版本主要的修改对象是软件的 UI。修改的的 Bug 经测试人 员测试确认后可发布到外网上，此时可将软件版本标注为 beta 版。RC该版本已经相当成熟，基本上不存在导致错误的 Bug，与即将发行的正式版本相差无几。Release该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。版本号的写法version 必须确切匹配这个 version&gt;version 必须大于这个 version&gt;=version 必须大于等于这个 version&lt;version 必须小于这个 version&lt;=version 必须小于等于这个 version~version 大约相当于 version^version 与 version 兼容1.2.x 可以是 1.2.0、1.2.1 等，但不能是 1.3.0http://... URL 作为依赖项* 匹配任何版本&quot;&quot;(空字符串) 匹配任何版本，和 * 一样version1 - version2 相当于 &gt;=version1 &lt;=version2range1 || range2 range1 或 range2 其中一个满足时采用该 versiongit... Git URL 作为依赖项user/repo GitHub URLstag 一个以 tag 发布的指定版本，参考 npm-tagpath/path/path 本地 Paths域级包管理以@开头的包名由于用@声明了该包，npm 会默认将此包认定为私有包，而在 npm 上托管私有包是需要收费的，所以为了避免发布私有包，可以在发布时添加--accss=public 参数告知 npm 这不是一个私有包域级包不一定就是私有包，但是私有包一定是一个域级包在安装域级包时需要按照域级包全名来安装：npm install @scopeName/package发布一个支持 tree shaking 机制的包tree shaking 是依赖 ES Module 的模块特性来工作的，那是因为 ES Module 模块的依赖关系是在编译时确定的（和运行时无关），并且之后不能再改变，所以基于此特性可以进行可靠的静态分析设置 module 字段：该字段指向一个既符合 ES Module 模块规范但是又使用 ES5 语法的源文件。这么做的目的是为了启动 tree shaking 的同时，又避免代码兼容性的问题{  &quot;main&quot;: &quot;./lib/index.js&quot;, // 指向 CommonJS 模块规范的代码入口文件  &quot;module&quot;: &quot;./lib/index.es.js&quot; // 指向 ES Module 模块规范的代码入口文件}如上配置要求你的包中要发布两种模块规范的版本。如果你的 npm 环境支持 module 字段，则会优先使用 ES Module 模块规范的入口文件，如果不支持则会使用 CommonJS 模块规范的入口文件。其实要想发布一个支持 tree shaking 机制的包，最主要是要构建出一个符合 module 字段要求的源文件，也就是一个既符合 ES Module 模块规范但是又采用 ES5 语法的源文件。rollup 可以直接构建出符合 ES Module 模块规范的文件，但是 webpack 不能。所以我们只需要使用 rollup 提供的构建能力，在配置文件中把 output 的格式设置为 es 即可为了更好地使用 ES Module 模块规范来开启 tree shaking 功能，优先选用 rollup 来开发 npm 包基于 ES6 模块规范是为了用户在使用我们的包时可以享受 Tree Shaking 带来的好处；使用 ES5 语法书写是为了用户在配置 babel 插件时可以放心的屏蔽 node_modules 目录"},{"id":"前端技术\\Typescript.md","filename":"Typescript.md","basename":"Typescript","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"Typescript什么是 typescriptTypescript 是强类型的 Javascript 超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript 并不直接在浏览器上运行，需要编译器编译成纯 Javascript 来运行，对 js 进行静态类型检查为什么用 ts使工程更严谨参数校验，利于团队规范基础类型number、string、boolean、Array、object、Symbol、Tuple、enum、never、void、null、undefined、any泛型泛型代表的是泛指某一类型，更像是一个类型变量。由尖括号包裹主要作用是创建逻辑可复用的组件泛型可以作用在函数、类、接口上泛型还可以被约束使用泛型的场景当你的函数、接口或类将处理多种数据类型时当函数、接口或类在多个地方使用该数据类型时类型断言我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法就可以使用断言类型断言对运行没有什么影响，仅供编译器使用。向编译器提供我们所希望的分析代码的提示。表示断言的两种方式： 1：&lt;类型&gt;变量 2：变量 as 类型 （在 tsx 中只能使用这种方式）TS 接口可以定义对象、数组、函数、类等作用就是为一个变量类型进行命名，定义契约可以相互继承可以继承类可选属性与额外检查TS 类特性：继承、多态、抽象、封装、实例TS 装饰器是一种特殊类型的声明，它能被附加在类、方法、属性、访问符、参数上装饰器使用@expression 这种方式，expression 求值后必须为一个函数，它在运行时调用，被装饰器声明的信息作为参数传入Declare在.ts 中使用的第三方库时没有.d.ts 声明文件的时候，我们可以通过 declare 来写申明文件可以声明该模块，甚至可以直接声明一个值为 any 的同名的变量，然后我们就可以在代码中直接使用该三方库了tsconfig.json该文件存在于 Typescript 项目的根目录里，其作用是指定相关选项告诉 ts 编译器如何编译 ts 文件.d.ts 文件用 ts 写的模块在发布的时候仍然是用 js 发布，这就导致一个问题：ts 那么多类型数据都没了，所以需要一个 d.ts 文件来标记某个 js 库里面对象的类型然后 typings 就是一个网络上的 d.ts 数据库对编辑器能有智能提示"},{"id":"前端技术\\Webpack.md","filename":"Webpack.md","basename":"Webpack","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"Webpack是一个 JavaScript 的模块打包工具基于入口文件，自动地递归解析入口所需要加载的所有资源，然后用不同的 loader 来处理不同的文件，用 Plugin 来扩展 webpack 的功能通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包，供 HTML 直接引用实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量概念Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；Module: 源码目录中的每一个文件，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；Chunk: webpack 打包过程中的产物，在进行模块的依赖分析的时候，代码分割出来的代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；Loader: 模块加载器，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElement；Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；Bundle: webpack 打包出来的文件，webpack 最终输出的东西，可以直接在浏览器运行。在抽离 css(当然也可以是图片、字体文件之类的)的情况下，一个 chunk 是会输出多个 bundle 的，但是默认情况下一般一个 chunk 也只是会输出一个 bundle工作流程初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译确定入口：根据配置中的 entry 找出所有的入口文件，生成依赖关系图编译模块，发广播：按文件类型，调用相应的 Loader 对模块进行编译，并在合适的时机点触发广播事件，Plugin 收听这些事件执行相应方法，再找出该模块依赖的模块，递归执行本步骤输出资源：将编译后的所有代码包装成一个个代码块（Chunk），并按依赖和配置确定输出内容，这个步骤，仍然可以通过 Plugin 进行文件的修改，是可以修改输出内容的最后机会保存：最后，根据 output 配置，把文件内容一一写入到文件系统，完成文件指纹hash：所有的 bundle 使用同一个 hash 值，跟每一次 webpack 打包的过程有关chunkhash：根据每一个 chunk 的内容进行 hash，同一个 chunk 的所有 bundle 产物的 chunkhash 值是一样的。因此若其中一个 bundle 的修改，同一 chunk 的所有产物 hash 也会被修改contenthash：与文件内容本身相关注意：开发环境热更新下只能使用 hash 或者不使用 hash。在生产环境中我们一般使用 contenthash 或者 chunkhash，因为在热更新模式下，会导致 chunkhash 和 contenthash 计算错误Plugin// 示例class MyPlugin {  // 构造方法  constructor (options) {    console.log(&#x27;MyPlugin constructor:&#x27;, options);  }  // 应用函数  apply (compiler) {    // Compiler 对象包含了 Webpack 环境所有的的配置信息，可以简单地把它理解为 Webpack 实例    // 绑定钩子事件    compiler.plugin(&#x27;compilation&#x27;, compilation =&gt; {      // Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等      console.log(&#x27;MyPlugin&#x27;)    ));  }}module.exports = MyPluginhttps://www.webpackjs.com/contribute/writing-a-plugin/在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果钩子https://www.webpackjs.com/api/compiler-hooks/https://www.webpackjs.com/api/compilation-hooks/Loader模块加载器，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElementwebpack 只认识 JavaScript，Loader 将资源转化成 Webpack 可以理解的内容形态通常是一个函数module.exports = function (source, sourceMap?, data?) {  // source：为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果  // sourceMap：可选参数，代码的 sourcemap 结构  // data：可选参数，其它需要在 Loader 链中传递的信息  return source;};通过 return 语句返回处理结果，除此之外 Loader 还可以以 callback 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用，callback 签名：this.callback(  // 异常信息，Loader 正常运行时传递 null 值即可  err: Error | null,  // 转译结果  content: string | Buffer,  // 源码的 sourcemap 信息  sourceMap?: SourceMap,  // 任意需要在 Loader 间传递的值  // 经常用来传递 ast 对象，避免重复解析  data?: any);常见 loaderimage-loader：加载并且压缩图片文件file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能、把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；ts-loader: 加载 ts / tsx 文件，编译 TypeScript；style-loader: 将 css 代码以 style 标签形式插入处理顺序从右向左webpack 分包默认的分包规则同一个 entry 下触达到的模块组织成一个 chunk异步模块单独组织为一个 chunkentry.runtime 单独组织成一个 chunk配置 splitChunksmodule.exports = {  splitChunks: {    // 表示选择哪些 chunks 进行分割，可选值有：async，initial和all    chunks: &#x27;async&#x27;,    // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。    minSize: 30000,    // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。    minChunks: 1,    // 表示按需加载文件时，并行请求的最大数目。默认为5。    maxAsyncRequests: 5,    // 表示加载入口文件时，并行请求的最大数目。默认为3。    maxInitialRequests: 3,    // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js    automaticNameDelimiter: &#x27;~&#x27;,    // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。    name: true,    // cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。    cacheGroups: {      vendors: {        test: /[\\\\/]node_modules[\\\\/]/,        priority: -10,      },      default: {        minChunks: 2,        priority: -20,        reuseExistingChunk: true,      },    },  },};Runtime（运行时代码） 分包Webpack 5 之后还能根据 entry.runtime 配置单独打包运行时代码除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtimerollup 和 webpack 区别webpack 拆分代码， 按需加载；Rollup 所有资源放在同一个地方，一次性加载，利用 tree-shake 特性来剔除项目中未使用的代码，减少冗余对于应用使用 webpack，对于类库使用 Rollup，rollup 适用于基础库的打包，如 vue、react如果你需要代码拆分(Code Splitting)，或者你有很多静态资源需要处理，再或者你构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望你写的代码能够被其他人直接使用，你需要的打包工具可能是 Rollup。Tree-Shaking含义基于 ES Module 规范的死码删除技术在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾被其它模块使用，并将其删除，以此实现打包产物的优化实现原理https://juejin.cn/post/7019104818568364069实现 Tree Shaking 技术的必要条件在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用"},{"id":"前端技术\\函数式编程.md","filename":"函数式编程.md","basename":"函数式编程","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"函数式编程是什么函数式编程是一种编程范式，目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变，旨在尽可能地提高代码的无状态性和不变性主要思想是把运算过程尽量写成一系列嵌套的函数调用，比如柯里化、react 的高阶函数函数式库：Ramda.js、lodash、RxJS命令模式中 run 函数的好处将函数本身参数化，非侵入式的修改函数，无需重写任何内部逻辑为什么纯函数易于维护：无状态的代码不会改变或破坏全局的状态易于测试：不依赖外部资源的算法灵活便于重用、保持业务逻辑代码的纯净任务分解，一定程度增加代码可读性函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的"},{"id":"前端技术\\微前端.md","filename":"微前端.md","basename":"微前端","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"微前端微前端不一定是一种新技术，也不必太复杂。只要我们保证代码隔离和团队自治，无论我们采用何种技术栈，我们都可以达到相同的效果由来工程越来越大，打包越来越慢团队人员多，产品功能复杂，代码冲突频繁、影响面大在后端服务开发中，为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了微服务架构把应用程序设计成一系列松耦合的细粒度服务允许使用不同的编程语言来编写不同服务前端也出现这样的问题，即，一种由独立交付的多个应用组成整体的架构风格。将前端应用分解成一些更小更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发传统开发的缺点历史项目，祖传代码交付压力，当时求快就近就熟，当时求稳导致技术栈落后，甚至强行混用多种技术栈，耦合混乱，不敢动，牵一发动全身每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），且要能独立部署，不必过多考虑其它代码库的状态意义技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略独立运行时，每个微应用之间状态隔离，运行时状态不共享微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。技术方案package 集成将每个微前端发布为一个 npm 包，并让容器应用程序将所有微前端应用作为依赖项这意味着只要有一个包更新，即使是小版本，宿主也要重新构建一次。不建议使用这种方案iframe优点：隔离得很彻底缺点：速度慢，浏览器处理 iframe 要启动更多的进程；页面刷新难以保存状态，路由、历史记录等等使用 umd 包通过 script 标签引入放在 cdn 上的资源，可以始终保持最新，子应用更新不需要通知宿主具有完全的灵活性，宿主可以控制什么时候载入每个应用，以及渲染应用时额外传参数微前端架构存在的一些普遍问题下载量独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React环境差异在本地开发时无法把所有微应用和对应的后端都启动起来，不得不在本地进行环境的简化。如果开发环境和生产环境不严谨一致，容易造成问题。如果开发者想要完全模拟生产环境，会比较耗时治理复杂性要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等"},{"id":"前端技术\\性能优化.md","filename":"性能优化.md","basename":"性能优化","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"性能优化代码层面缓存 dom 查找结果用 innerHTML 代替 DOM 操作，减少 DOM 操作次数不频繁修改 DOM如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称// badconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.borderLeft = &#x27;1px&#x27;;el.style.borderRight = &#x27;2px&#x27;;el.style.padding = &#x27;5px&#x27;;// goodconst el = document.querySelector(&#x27;.myDiv&#x27;);el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// cssText会覆盖已存在的样式，所以使用 +=列表绑定事件，使用事件委托如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快CSS 能做的事情，尽量不用 JS 来做避免 css 表达式比如 calcwebpack、babel 层面webpack 按需加载，React.lazy + import()，Webpack 4 之后，只需要用异步语句 require.ensure(&quot;./xx.js&quot;) 或 import(&quot;./xx.js&quot;) 方式引入模块，就可以实现模块的动态加载，这种能力本质也是基于 Chunk 实现的，遇到异步引入语句时会为该模块单独生成一个 chunkwebpack 配置 external，将通用库抽离，不打包进 bundle，比如 jquery、lodash，使用 CDN，并开启强缓存配置 babel 动态 polyfill，只针对不支持的浏览器引入 polyfill配置 file-loader，使小图使用 base64借助 webpack-bundle-analyzer 工具分析打包出的文件包含哪些，大小占比如何，模块包含关系webpack 的 tree-shaking 删除多余代码antd 按需加载，babel-plugin-importwebpack 拆包优化其他不常修改的资源（jquery），开启强缓存优化，配置响应头 Cache-Control 与 Expires减少 http 请求次数：雪碧图、小图片使用字体图标代替css 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async单页应用首屏加载放个 loading，优化用户感知，利用一些过渡效果、骨架屏使用 link 标签的 rel 属性，设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢压缩 js、css 代码减少 cookie 的体积使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，会得到缓存服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）路由懒加载图片懒加载将静态资源放在其他域名的原因（CDN）浏览器对于相同域名有并发请求数限制请求时不会发送 cookie，节省了流量cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名script 标签的 defer 和 async没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。defer：立即下载，将延迟到整个页面都解析完毕后再运行js 为什么放最下面？当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，比如 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的css 为什么放最上面？CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染css 是由单独的下载线程异步下载的但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）gzip只对文本文件有效，比如 js、css，流文件无效，比如图片需要客户端和服务端的同时支持客户端支持：请求头中有个 Accept-Encoding 来标识对压缩的支持，content-encoding: gzip服务端支持：能够返回经过 gzip 压缩的文件重绘（repaint）与回流（reflow）重绘：当元素样式的改变不影响布局时，触发重绘，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。回流、重排：当元素的尺寸、结构或触发某些属性时，触发回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较耗性能的操作。触发回流的操作：页面初次渲染浏览器窗口大小改变元素尺寸、位置、内容发生改变元素字体大小变化添加或者删除可见的 dom 元素激活 CSS 伪类（例如：:hover）查询某些属性或调用某些方法回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。如何避免触发回流和重绘CSS：避免使用 table 布局。尽可能在 DOM 树的最末端改变 class。避免设置多层内联样式。将动画效果应用到 position 属性为 absolute 或 fixed 的元素上避免使用 CSS 表达式（例如：calc()）CSS3 硬件加速（GPU 加速）JavaScript：避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘优势在于可以充分利用显示器的刷新机制，比较节省系统资源显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命当浏览器渲染线程被过度占用时这个 API 调用间隔会非常不稳定，它并不是银弹使用：function test(timestamp) {  console.log(timestamp);  requestAnimationFrame(test);}requestAnimationFrame(test);"},{"id":"前端技术\\柯里化.md","filename":"柯里化.md","basename":"柯里化","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"柯里化把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术参考https://zh.javascript.info/currying-partials意义让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用减少耦合增强其可维护性缺点过度使用会占用较大的堆栈空间经过柯里化之后，函数的通用性有所降低，但是适用性有所提高实现// 手写柯里化const add = function (a, b, c) {  return a + b + c;};function curry(fn) {  return function curryFun(...args) {    if (args.length &lt; fn.length) {      return function () {        return curryFun([...args, ...arguments]);      };    }    return fn(...args);  };}const curried = curry(add);const a = curried(1)(9)(3);const b = curried(2, 8)(6);console.log({ a, b });"},{"id":"前端技术\\设计模式.md","filename":"设计模式.md","basename":"设计模式","path":"D:\\repos\\doc-builder\\markdown\\前端技术","relative_path":"前端技术","output_path":"D:\\repos\\doc-builder\\docs\\前端技术","content":"设计模式设计模式原则单一职责原则一个程序只做好一件事如果功能过于复杂就拆分开，每个部分保持独立比如 Promise，每个 then 只做一件事开放/封闭原则对扩展开放，对修改封闭增加需求时，扩展新代码，而非修改已有代码比如 Promise，如果新增需求，扩展 then比如为表单校验类增加拓展接口而不是修改内部代码// 优化前let checkType = function (str, type) {  switch (type) {    case &#x27;email&#x27;:      return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);    case &#x27;mobile&#x27;:      return /^1[3|4|5|7|8][0-9]{9}$/.test(str);    case &#x27;tel&#x27;:      return /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str);    default:      return true;  }};// const result = checkType(&#x27;165226226326&#x27;,&#x27;mobile&#x27;)// 优化后let checkType = (function () {  let rules = {    email(str) {      return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);    },    mobile(str) {      return /^1[3|4|5|7|8][0-9]{9}$/.test(str);    },  };  //暴露接口  return {    //校验    check(str, type) {      return rules[type] ? rules[type](str) : false;    },    //添加规则    addRule(type, fn) {      rules[type] = fn;    },  };})();console.log(checkType.check(&#x27;188170239&#x27;, &#x27;mobile&#x27;));checkType.addRule(&#x27;money&#x27;, function (str) {  return /^[0-9]+(.[0-9]{2})?$/.test(str);});console.log(checkType.check(&#x27;18.36&#x27;, &#x27;money&#x27;));里氏替换原则子类能覆盖父类父类能出现的地方子类就能出现接口隔离原则保持接口的单一独立依赖倒转原则面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类的实现设计模式分类创建型单例模式原型模式工厂模式抽象工厂模式建造者模式组合型（结构型）适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式行为型观察者模式迭代器模式策略模式模板方法模式职责链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式工厂模式场景需要依赖具体环境创建不同实例，实例都有相同的行为扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以示例class Product {  constructor(name) {    this.name = name;  }  init() {    console.log(&#x27;init&#x27;);  }  fun() {    console.log(&#x27;fun&#x27;);  }}class Factory {  create(name) {    return new Product(name);  }}let factory = new Factory();let p = factory.create(&#x27;p1&#x27;);p.init();p.fun();单例模式场景：登录框、vuex 和 redux 中的 store一个类只有一个实例，并提供一个访问它的全局访问点划分命名空间，减少全局变量只会实例化一次。简化了代码的调试和维护，节约内存有可能导致模块间的强耦合，从而不利于单元测试示例class LoginForm {  constructor() {    this.state = &#x27;hide&#x27;;  }  show() {    if (this.state === &#x27;show&#x27;) {      return;    }    this.state = &#x27;show&#x27;;    console.log(&#x27;显示&#x27;);  }  hide() {    if (this.state === &#x27;hide&#x27;) {      return;    }    this.state = &#x27;hide&#x27;;    console.log(&#x27;隐藏&#x27;);  }}LoginForm.getInstance = (function () {  let instance;  return function () {    if (!instance) {      instance = new LoginForm();    }    return instance;  };})();let obj1 = LoginForm.getInstance();obj1.show();let obj2 = LoginForm.getInstance();obj2.hide();console.log(obj1 === obj2); // true适配器模式将一个类的接口转化为另外一个接口，以满足需求，使类之间接口不兼容问题通过适配器得以解决可以让任何两个没有关联的类一起运行，提高了类的复用额外对象的创建，非直接调用，存在一定的开销场景：整合第三方 SDK、封装旧接口适配器与代理模式相似，适配器模式提供一个不同的接口，代理模式提供一模一样的接口示例class Plug {  getName() {    return &#x27;iphone充电头&#x27;;  }}class Target {  constructor() {    this.plug = new Plug();  }  getName() {    return this.plug.getName() + &#x27; 适配器Type-c充电头&#x27;;  }}let target = new Target();target.getName();// 自己封装的ajax， 使用方式如下ajax({ url: &#x27;/getData&#x27;, type: &#x27;Post&#x27;, dataType: &#x27;json&#x27;, data: { test: 111 } }).done(function () {});// 因为历史原因，代码中全都是：// $.ajax({....})// 做一层适配器var $ = {  ajax: function (options) {    return ajax(options);  },};装饰者模式在不改变原对象的基础上，动态的给对象添加额外职责，对其进行包装扩展，是实现继承的一种替代方案装饰类和被装饰类都只关心自身的核心业务，实现了解耦方便动态的扩展功能，且提供了比继承更多的灵活性缺点多层装饰比较复杂常常会引入许多小对象，看起来比较相似，实际功能大相径庭代理模式为一个对象提供一个代用品或占位符，以便控制对它的访问能将代理对象与被调用对象分离，降低耦合度，可以起到保护目标对象的作用代理对象可以扩展目标对象的功能，通过修改代理对象就可以了，符合开闭原则场景做授权控制HTML 元素事件代理ES6 的 proxy缺点处理请求速度可能有差别，非直接访问存在开销外观模式为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用减少系统相互依赖，提高灵活性、安全性缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适场景兼容浏览器事件绑定设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作观察者模式（发布订阅模式）定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式缺点：过度使用会导致对象与对象之间的联系弱化，会导致难以跟踪维护和理解场景DOM 事件vue 事件总线状态模式允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类迭代器模式提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示访问一个聚合对象的内容而无需暴露它的内部表示为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式场景Array.prototype.forEachES6 Iterator示例class Iterator {  constructor(conatiner) {    this.list = conatiner.list;    this.index = 0;  }  next() {    if (this.hasNext()) {      return this.list[this.index++];    }    return null;  }  hasNext() {    if (this.index &gt;= this.list.length) {      return false;    }    return true;  }}class Container {  constructor(list) {    this.list = list;  }  getIterator() {    return new Iterator(this);  }}let container = new Container([1, 2, 3, 4, 5]);let iterator = container.getIterator();while (iterator.hasNext()) {  console.log(iterator.next());}桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化有助于独立地管理各组成部分， 把抽象化与实现化解耦大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少示例class Color {  constructor(name) {    this.name = name;  }}class Shape {  constructor(name, color) {    this.name = name;    this.color = color;  }  draw() {    console.log(`${this.color.name} ${this.name}`);  }}let red = new Color(&#x27;red&#x27;);let yellow = new Color(&#x27;yellow&#x27;);let circle = new Shape(&#x27;circle&#x27;, red);circle.draw();let triangle = new Shape(&#x27;triangle&#x27;, yellow);triangle.draw();组合模式通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象示例class TrainOrder {  create() {    console.log(&#x27;创建火车票订单&#x27;);  }}class HotelOrder {  create() {    console.log(&#x27;创建酒店订单&#x27;);  }}class TotalOrder {  constructor() {    this.orderList = [];  }  addOrder(order) {    this.orderList.push(order);    return this;  }  create() {    this.orderList.forEach((item) =&gt; {      item.create();    });    return this;  }}// 可以在购票网站买车票同时也订房间let train = new TrainOrder();let hotel = new HotelOrder();let total = new TotalOrder();total.addOrder(train).addOrder(hotel).create();原型模式用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象示例class Person {  constructor(name) {    this.name = name;  }  getName() {    return this.name;  }}class Student extends Person {  constructor(name) {    super(name);  }  sayHello() {    console.log(`Hello， My name is ${this.name}`);  }}let student = new Student(&#x27;xiaoming&#x27;);student.sayHello();策略模式组成：一组策略类，封装了具体的算法，并负责具体的计算过程；环境类，接受客户的请求，将请求委托给某一个策略定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换可以有效的避免多重条件选择语句提供了对开放-封闭原则的支持，将算法封装在独立的策略中，使得它们易于切换，理解，易于扩展场景一个系统需要动态地在几种算法中选择一种表单验证模板方法模式模板方法模式由抽象父类、具体的实现子类组成。在抽象父类中封装了子类的算法框架，实现一些公共方法和封装子类中所有方法的执行顺序子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法场景一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复示例class Beverage {  constructor({ brewDrink, addCondiment }) {    this.brewDrink = brewDrink;    this.addCondiment = addCondiment;  }  /* 烧开水，共用方法 */  boilWater() {    console.log(&#x27;水已经煮沸=== 共用&#x27;);  }  /* 倒杯子里，共用方法 */  pourCup() {    console.log(&#x27;倒进杯子里===共用&#x27;);  }  /* 模板方法 */  init() {    this.boilWater();    this.brewDrink();    this.pourCup();    this.addCondiment();  }}/* 咖啡 */ const coffee = new Beverage({  /* 冲泡咖啡，覆盖抽象方法 */  brewDrink: function () {    console.log(&#x27;冲泡咖啡&#x27;);  },  /* 加调味品，覆盖抽象方法 */  addCondiment: function () {    console.log(&#x27;加点奶和糖&#x27;);  },});coffee.init();命令模式将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行示例// 接收者类class Receiver {  execute() {    console.log(&#x27;接收者执行请求&#x27;);  }}// 命令者class Command {  constructor(receiver) {    this.receiver = receiver;  }  execute() {    console.log(&#x27;命令&#x27;);    this.receiver.execute();  }}// 触发者class Invoker {  constructor(command) {    this.command = command;  }  invoke() {    console.log(&#x27;开始&#x27;);    this.command.execute();  }}// 仓库const warehouse = new Receiver();// 订单const order = new Command(warehouse);// 客户const client = new Invoker(order);client.invoke();中介者模式所有的相关对象都通过中介者对象来通信，而不是互相引用使网状的多对多关系变成了相对简单的一对多关系类似于观察者模式，但是单向的，由中介者统一管理例如表单的 onchange 事件，无论是输入框还是单选按钮，都统一与 onchange 通信，由 onchange 统一处理事件类型的差异，实现各个事件间的解耦"}]},{"id":"单元测试.md","filename":"单元测试.md","basename":"单元测试","path":"D:\\repos\\doc-builder\\markdown","relative_path":"","output_path":"D:\\repos\\doc-builder\\docs","content":"参考https://zh.javascript.info/testing-mocha单元测试是指对软件中的最小可测试单元进行检查和验证当通过手动重新运行来测试代码时，很容易漏掉一些东西对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试自动化测试测试是独立于代码的以各种方式运行我们的函数，并将结果与预期结果进行比较行为驱动开发（BDD）规范先行，实现在后简单来说就是首先写一些暂时无法通过的测试，然后去实现它们包含了三部分内容：测试、文档和示例前端常用单元测试框架mocha、Jest 提供了单元测试所需的各种 API，你可以使用它们来对你的代码进行单元测试"},{"id":"网络.md","filename":"网络.md","basename":"网络","path":"D:\\repos\\doc-builder\\markdown","relative_path":"","output_path":"D:\\repos\\doc-builder\\docs","content":"参考https://www.cnblogs.com/leezhxing/p/4524176.htmlhttps://juejin.cn/post/6844904100035821575https://juejin.cn/post/6844903510509633550网络体系结构分层TCP/IP 通信传输流利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走发送端在层与层间传输数据时，没经过一层都会被加上首部信息，接收端每经过一层都会删除一条首部TCP/IP利用 IP 进行通信时所必须用到的协议群的统称具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议族端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址UDP处于 TCP/IP 分层模型中的传输层不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为传输途中出现丢包，UDP 也不负责重发甚至当包的到达顺序出现乱序时也没有纠正的功能应用：1.包总量较少的通信（DNS、SNMP 等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）TCP处于 TCP/IP 分层模型中的传输层充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）TCP 和 UDP 的区别tcp 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。tcp 提供可靠的服务。tcp 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。tcp 的首部较大为 20 字节，而 UDP 只有 8 字节。tcp 是面向连接的可靠性传输，而 UDP 是不可靠的。tcp 三次握手原因由 TCP 的自身特点可靠传输决定的，为了在数据通信开始之前先做好两端之间的准备工作客户端和服务端都需要知道各自是否可收发，因此需要三次握手，需要客户端和服务器端总共发送三个包以确认连接的建立第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象过程客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）服务器发回一个带 SYN=1，ACK=X+1，Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）客户端再回传一个带 ACK=Y+1，Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）简版：1：客户端 –-&gt; 发送带有 SYN 标志的数据包–-&gt;服务端（我要发送请求了~）2：服务端 –-&gt; 发送带有 SYN/ACK 标志的数据包 -–&gt; 客户端（我准备接受了，你赶紧发送吧~）3：客户端 –-&gt; 发送带有带有 ACK 标志的数据包 -–&gt; 服务端（我马上就发了，准备接受吧~）tcp 四次挥手终止 TCP 连接，需要客户端和服务端总共发送 4 个包以确认连接的断开由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭过程发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)简版：1：客户端 --&gt; 发送一个 FIN，用来关闭客户端到服务器的数据传送（我请求报文发送完了，你准备关闭吧~）2：服务器 --&gt; 收到这个 FIN，发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号（我请求报文接受完了，我准备关闭了，你也准备吧）3：服务器 --&gt; 关闭与客户端的连接，发送一个 FIN --&gt; 客户端（我响应报文发送完了，你准备关闭吧）4：客户端 --&gt; 发回 ACK 报文确认，并将确认序号设置为收到序号加 1（我响应报文接受完了，我准备关闭了，你也准备吧）HTTP超文本传输协议，是一个客户端和服务器端请求和应答的标准无状态、明文传输处于 TCP/IP 分层模型中的应用层浏览器实现了 http 缓存默认端口 80无状态性每次请求都建立新的连接，数据请求完毕立即断开，短连接（http1.1 开始已经支持长连接）协议对于发送过的请求或响应都不做持久化处理，为了更快地处理大量事务，确保协议的可伸缩性，特意设计得简单一些，保存状态需要引入 cookie 和 session，需要客户端实现 cookie 功能（浏览器），服务器实现 sessionHTTP 报文格式http 报文分为三部分：起始行、头部、主体三个部分以 CRLF 作为分隔符。最后一个消息头有两个 CRLF，用来表示消息头部的结束。起始行是对请求或响应的描述，形如 GET /index.html HTTP/1.1头部由很多键值对组成，多个键值对之间使用 CRLF 作为分隔符存放如 cookie、content-type 等主体存放数据，明文传输状态码1xx 信息，服务器收到请求，需要请求者继续执行操作2xx 成功，操作被成功接收并处理3xx 重定向，需要进一步的操作以完成请求4xx 客户端错误，请求包含语法错误或无法完成请求5xx 服务器错误，服务器在处理请求的过程中发生了错误100 表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略200 表明请求已经成功. 默认情况下状态码为 200 的响应可以被缓存201 表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。202 表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。204 表示目前请求成功，但客户端不需要更新其现有页面。301 永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。302 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在 GET 请求, 或在请求中附带了头部信息：If-None-Match 或 If-Modified-Since307 临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。308 永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。400 表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。401 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。403 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）404 说明服务器端无法找到所请求的资源。405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。500 表示所请求的服务器遇到意外的情况并阻止其执行请求，比如服务端代码语法错误502 表示作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的。504 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。比如 代码执行时间超时，或死循环了。301 和 302 区别302 重定向只是暂时的重定向，例如未登陆的用户访问用户中心重定向到登录页面。因为服务器返回 302，所以，搜索搜索引擎认为新的网址是暂时的，搜索引擎会抓取新的内容而保留旧的地址。301 重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址常见请求头Accept 可接受的响应内容类型CookieContent-Type 请求体的 MIME 类型OriginReferer 来源User-AgentCache-Control 强缓存相关Expires 强缓存相关Last-Modified 协商缓存相关Etag 协商缓存相关Access-Control-Allow-Origin 指定允许跨域的域名HTTP 1.1 新特性支持长连接，默认设置 Connection：keep-alive，TCP 连接在发送后将仍然保持打开状态，客户端可以继续通过相同的连接发送请求，节省了为每个请求建立新连接所需的时间，还节约了网络带宽断点续传身份认证状态管理cache 缓存头部标识Cache-ControlExpiresLast-ModifiedEtagHTTP 2.01.0 协议缺点：文本协议传输，不够安全无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手线头阻塞，导致请求之间互相影响Header 内容繁多，有时有可能会超过响应内容，并且每次有许多字段都是重复传输基于以上缺点，也出现了许多优化手段：雪碧图、合并脚本和样式表、资源内联、域名分片等优化工作，但是如果 HTTP 协议足够好的话，本可以避免这些额外的操作。2.0 新特性多路复用，单一长连接，二进制格式传输通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念头部压缩服务器推送在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待设置请求优先级HTTP 协议本身解决了队头阻塞问题原来 Headers + Body 的报文格式如今被拆分成了一个个二进制的帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。头部压缩算法首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如 0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个&quot;:&quot;前缀，用来和其它请求头区分开。多路复用在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手和 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题，一是串行的文件传输，二是连接数过多导致的性能问题。HTTP/2 的多路复用就是为了解决上述的两个性能问题。在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。队头阻塞问题由 HTTP 基本的“请求 - 应答”模型所导致因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列队列里的请求没有优先级，只有入队的先后顺序，排在最前面的请求被最优先处理如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本解决：域名分片，多开几个域名，而这些域名都指向同一个服务器定长与不定长包体响应头设置 Content-Length 指明包体的长度响应头设置 Transfer-Encoding: chunked 表示分块传输数据，Content-Length 字段会被忽略，基于长连接持续推送动态内容如何处理大文件的传输http 采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分客户端设置请求头：Range，格式为 bytes=x-y0-499 表示从开始到第 499 个字节500- 表示从第 500 字节到文件终点-100 表示文件的最后 100 个字节服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码服务器设置响应头：Accept-Ranges如何处理表单数据的提交体现在两种不同的 Content-Type 取值:application/x-www-form-urlencoded其中的数据会被编码成以&amp;分隔的键值对字符以 URL 编码方式编码multipart/form-data每一个表单元素都是独立的资源表述对于图片等文件的上传，基本采用 multipart/form-datapost 和 get 区别GET 和 POST 方法没有实质区别，只是报文格式不同。约定上，get 一般使用 url 传参，post 一般使用 body 传参，实际上 post 也可以 url 传参。GET 请求会被浏览器主动缓存下来，GET 没有副作用，点击浏览器后退和刷新按钮时，POST 的数据会被重新提交，GET 可以收藏为书签，GET 参数可被浏览器历史保存。GET 的参数长度受到浏览器限制，http 协议上并没有限制。POST 无限制。数据类型 GET 只允许传 ASCII 字符，POST 没有限制，允许传二进制数据。POST 并不比 GET 安全，只有 https 才是安全的。get 请求传参长度的误区：误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:HTTP 协议 未规定 GET 和 POST 的长度限制GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)https://segmentfault.com/a/1190000018129846https://juejin.im/post/59fc04ecf265da4317697f26cookie主要作用：会话状态管理、个性化设置、浏览器行为跟踪一段一般不超过 4KB 的小型文本数据由名称（name）、值（value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成Expires 用于设置 Cookie 的过期时间Max-Age 用于设置在 Cookie 失效之前需要经过的秒数Domain 指定了 Cookie 可以送达的主机名。Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。设置 HTTPOnly 属性可以防止客户端脚本访问 Cookie，保证安全，例如 XSS 攻击。SameSite 是最近非常值得一提的内容，因为新的 Chrome80 版本中默认屏蔽了第三方的 Cookiecookie 缺点大小只有 4kb、会增加请求大小个数限制、长度限制不安全，有可能被截获相比 localstorage， 需要自己封装 setter 和 gettercookie-sessionHTTP 是一个无状态的协议。为了解决 HTTP 无状态导致的问题，出现了 Cookie，为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。第一次请求服务端的时候，服务端响应报头出现一个 Set-Cookie 字段，在客户端设置一个 cookie，当再次请求服务端的时候，请求会附带这个 cookie 过去，cookie 中存有 sessionId 这样的信息来到服务端这边确认是否属于同一次会话。当客户端请求创建一个 session 的时候，服务端会先检查这个客户端的请求里是否已包含了一个 session 标识 - sessionId，如果已包含这个 sessionId，则说明以前已经为此客户端创建过 session，服务端就按照 sessionId 把这个 session 检索出来使用现在可使用 jwt 替代跨域请求如何携带 cookie服务端设置 Access-Control-Allow-Origin 响应头，为允许跨域的域服务端设置 Access-Control-Allow-Credentials 响应头 为 true请求时设置 withCredentials 为 truewithCredentials 是什么XMLHttpRequest 的一个请求配置指示了是否该使用类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制HTTPSHTTP + SSL(TLS) = HTTPS是以安全为目的设计，http 明文传输不安全网景公司（Netscape）设置了 SSL 协议来对 http 协议传输的数据包进行加密处理TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本需要 CA 证书，有成本默认端口号 443HTTPS 加解密流程：对称加密常见的有 AES 算法加密与解密用的是同样的一个密钥效率高密钥越大，加密越强，但加密与解密的过程越慢通常使用相对较小的密钥，一般小于 256 bit缺点：不安全，在发送密钥的过程中，密钥有很大的风险会被黑客们拦截存储成本：每一个客户要生成一个不同的 key解决：通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人非对称加密常用的非对称加密算法是 RSA 算法使用了一对密钥，公钥 和 私钥，公钥进行加密，私钥用于解密私钥只能由一方安全保管，不能外泄，公钥可以发给任何请求它的人发送前，发送方先索要接受方公钥，发送方得到公钥后用其加密发送内容，接收方使用私钥解密内容不需要将私钥通过网络发送出去，因此安全性大大提高缺点：RSA 的运算速度非常慢（而对称加密的 AES 的加密速度比较快），效率低，性能问题对称与非对称结合（混合加密）在通信刚开始的时候使用非对称加密进行一系列认证，后续通信使用对称加密：接收方生成：非对称公钥和私钥发送方向接收方索要非对称公钥发送方生成：一个临时的对称加密密钥，往往是生成一个随机数发送方将对称密钥使用非对称公钥进行加密，然后发送接收方使用非对称私钥进行解密得到对称密钥然后双方可以使用对称加密来进行沟通中间人攻击（伪造非对称公钥）针对混合加密第一步，中间人可以伪造非对称公钥黑客事先设好自己的非对称公钥和私钥当黑客截获了发送方向接收方索取非对称公钥的消息，就把自己的非对称公钥发给发送方，同时也把截到的发送方的消息，继续发给接收方接收方收到索取公钥的请求，将公钥发送回并附带了一条信息，黑客截获了这个公钥之后，只将信息和黑客的公钥发给发送方，接收方的公钥黑客自己保留之后发送方就用了黑客的非对称公钥去加密自己的消息发给接收方，被黑客截获，黑客再用自己的非对称私钥去解密甚至可以随意篡改消息内容，用之前保留的接收方的公钥去加密消息，再发给接收方解决第三方公证机构（CA）介入接收方使用自己的公钥去 CA 开证明，CA 将接收方公钥、必要信息等包装成一个证书，能够证明接收方身份收到这个证书的发送方，就能确认这是接收方的公钥防止证书在传输过程中被黑客篡改服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性接收方先把自己的公钥和必要信息用一个 hash 算法生成一个 数字摘要hash 算法特性：只要信息内容有一点的更改，重新使用该算法生成的 数字摘要 内容将会产生巨变CA 有自己的私钥和公钥CA 使用自己的私钥对该 数字摘要 进行加密，生成 数字签名把接收方的必要信息和 数字签名 合并，得到 数字证书发送方向接收方索要公钥时，接收方就把证书发给发送方发送方收到证书后，先用从证书内拿到的 hash算法 对接收方的原始信息生成新的 数字摘要再用 CA 的公钥对 数字签名 进行解密，也生成一个 数字摘要，如果接收方的信息被篡改了，hash 生成的摘要将会与 CA 公钥解密得到的摘要有巨大的不同由此可判定传过来的公钥等其他信息是否被中途篡改过如何验证证书的合法性首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内；浏览器开始查找操作系统中已内置的受新人的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发；如果找不到，浏览器就会报错，说明浏览器发来的证书是不可信任的；如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥（多数浏览器开发商发布版本时，会实现在内部植入常用认证机关的公开密钥），然后对服务器发来的证书里面的签名进行解密；浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比；对比结果一致，则证明服务器发来的证书合法，没有被冒充；SSL/TLS处于会话层TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本，用于在互联网两台计算机之间用于身份验证和加密的一种协议通常情况下，HTTP 会先直接和 TCP 进行通信， 使用 SSL 后，则会先和 SSL 进行通信，然后再由 SSL 和 TCP 进行通信，HTTPS 就是身披了一层 SSL 的 HTTPSSL 是一个独立的协议，不只有 HTTP 可以使用，其他应用层协议也可以使用，比如 SMTP(电子邮件协议)、Telnet(远程登录协议) 等都可以使用TLS 的结构密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 组成的一个密码串ECDHE-ECDSA-AES256-GCM-SHA384# 使用 ECDHE 进行密钥交换，使用 ECDSA 进行签名和认证，然后使用 AES 作为对称加密算法，密钥的长度是 256 位，使用 GCM 作为分组模式，最后使用 SHA384 作为摘要算法"}]